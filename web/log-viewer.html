<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Log Viewer</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <style>
    :root{
      --bg:#0b0f14; --fg:#eef2f7; --muted:#94a3b8;
      --card:#0b1220; --line:#243045;
      --btn:#1e40af; --btn2:#334155; --th:#0f172a;
    }
    html,body{height:100%}
    body{background:var(--bg);color:var(--fg);font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:16px}
    header{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
    h2{margin:0 12px 0 0;font-size:20px}
    button{background:var(--btn);color:#fff;border:0;border-radius:8px;padding:8px 12px;cursor:pointer}
    button.btn2{background:var(--btn2)}
    select, input[type="text"]{background:#0b1220;color:#e5e7eb;border:1px solid var(--line);border-radius:6px;padding:6px 8px}
    label{display:flex;align-items:center;gap:6px}
    #meta{margin-left:auto;font-size:12px;color:#cbd5e1}
    #log{height:calc(100vh - 76px);overflow:auto;background:#0b1220;border:1px solid var(--line);border-radius:8px;padding:10px;white-space:pre-wrap;margin:0}
    a.link{color:#93c5fd;text-decoration:none}
  </style>
</head>
<body>
  <header>
    <h2 id="title">Logs</h2>

    <input id="tbName" type="text" placeholder="process name" style="min-width:140px">
    <select id="selDate" title="date"></select>
    <select id="selTail" title="tail bytes">
      <option value="20000">20 KB</option>
      <option value="50000" selected>50 KB</option>
      <option value="200000">200 KB</option>
      <option value="1000000">1 MB</option>
    </select>
    <label title="auto refresh"><input type="checkbox" id="cbAuto" checked> auto</label>
    <button id="btnRefresh" class="btn2">Refresh</button>
    <span id="meta">-</span>
  </header>

  <pre id="log">(loading...)</pre>

<script>
(function(){
  /* ───────── Proxy 지원: /proxy/<node>/ 자동감지 + fetch 패치 ───────── */
  const PROXY_NODE = (() => {
    const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
    return m ? decodeURIComponent(m[1]) : "";
  })();

  if (PROXY_NODE) {
    // <base> 주입: 상대경로를 /proxy/<node>/ 기준으로 해석
    const base = document.createElement("base");
    base.href = `/proxy/${encodeURIComponent(PROXY_NODE)}/`;
    document.head.prepend(base);

    // fetch 패치: 절대경로("/...") 앞에 /proxy/<node> 자동부착
    const orig = window.fetch;
    window.fetch = function(input, init){
      let url = (typeof input === "string") ? input : (input && input.url) || "";
      if (typeof url === "string" && url.startsWith("/") && !url.startsWith("/proxy/")) {
        url = `/proxy/${encodeURIComponent(PROXY_NODE)}${url}`;
      }
      if (typeof input !== "string" && input && input.url) {
        return orig(new Request(url, input), init);
      }
      return orig(url, init);
    };
  }

  /* ───────── Query Params ───────── */
  const qs = new URLSearchParams(location.search);
  const NODE_Q = qs.get("node") || "";            // 쿼리의 node (없어도 됨)
  const NAME0  = qs.get("name") || "";
  const DATE0  = qs.get("date") || "";
  const TAIL0  = qs.get("tail") || "";
  const AUTO0  = qs.get("auto");                  // "1"|"0"|null

  /* ───────── Mode / Base URL ─────────
     우선순위: ① URL이 /proxy/<node>/로 열렸으면 그 노드 사용
               ② 쿼리에 node= 있으면 그 노드 사용
               ③ 그 외에는 로컬(DMS 직접 접근) */
  const EFFECTIVE_NODE = PROXY_NODE || NODE_Q;
  const BASE = EFFECTIVE_NODE ? `/proxy/${encodeURIComponent(EFFECTIVE_NODE)}` : "";

  /* ───────── DOM ───────── */
  const title     = document.getElementById("title");
  const tbName    = document.getElementById("tbName");
  const selDate   = document.getElementById("selDate");
  const selTail   = document.getElementById("selTail");
  const cbAuto    = document.getElementById("cbAuto");
  const btnRefresh= document.getElementById("btnRefresh");
  const meta      = document.getElementById("meta");
  const logEl     = document.getElementById("log");
  let timer = null;

  if (TAIL0) cbAuto.value = TAIL0;
  if (AUTO0 === "0") cbAuto.checked = false;
  tbName.value = NAME0;

  function setTitle(){
    const nm = tbName.value.trim() || "(unknown)";
    title.textContent = EFFECTIVE_NODE ? `Logs • ${nm} @ ${EFFECTIVE_NODE}` : `Logs • ${nm}`;
  }
  setTitle();

  /* ───────── Fetch helper ───────── */
  async function jget(path){
    const r = await fetch(path, {cache:"no-store"});
    const ct = r.headers.get("content-type") || "";
    const isJson = ct.includes("application/json");
    if(!r.ok){
      let msg;
      try{ msg = isJson ? (await r.json()).error || r.statusText : await r.text(); }catch{ msg = r.statusText; }
      throw new Error(msg || `HTTP ${r.status}`);
    }
    return isJson ? r.json() : r.text();
  }

  /* ───────── Dates load ───────── */
  async function loadDates(){
    selDate.innerHTML = "";
    const name = tbName.value.trim();
    if(!name){
      const opt=document.createElement("option");
      opt.value=""; opt.textContent="(enter name)";
      selDate.appendChild(opt);
      return;
    }
    try{
      const url = `${BASE}/logs/list/${encodeURIComponent(name)}`;
      const r = await jget(url);
      const dates = (r && r.dates) || [];
      if(dates.length === 0){
        const opt = document.createElement("option");
        opt.value=""; opt.textContent="(no logs)";
        selDate.appendChild(opt);
      }else{
        dates.forEach(d=>{
          const opt=document.createElement("option");
          opt.value=d; opt.textContent=d;
          selDate.appendChild(opt);
        });
        if(DATE0 && dates.includes(DATE0)) selDate.value = DATE0;
      }
    }catch(e){
      const opt=document.createElement("option");
      opt.value=""; opt.textContent="(load failed)";
      selDate.appendChild(opt);
    }
  }

  /* ───────── Log refresh ───────── */
  async function refresh(){
    const name = tbName.value.trim();
    if(!name){
      logEl.textContent = "(name required)";
      meta.textContent = "-";
      return;
    }
    const params = new URLSearchParams();
    const d = selDate.value;
    if(d) params.set("date", d);
    params.set("tail", selTail.value || "50000");
    try{
      const url = `${BASE}/logs/${encodeURIComponent(name)}?${params.toString()}`;
      const r = await jget(url);
      if(r && r.ok){
        logEl.textContent = r.text || "";
        meta.textContent = `${r.path} • ${r.size} bytes • date ${r.date} • tail ${r.tail} bytes`;
        logEl.scrollTop = logEl.scrollHeight; // stick bottom
      }else{
        logEl.textContent = (r && r.error) ? r.error : "(no content)";
        meta.textContent = "-";
      }
    }catch(e){
      logEl.textContent = String(e.message || e);
      meta.textContent = "-";
    }
  }

  /* ───────── Auto refresh ───────── */
  function startAuto(){
    stopAuto();
    if(cbAuto.checked){
      timer = setInterval(refresh, 2000);
    }
  }
  function stopAuto(){
    if(timer){ clearInterval(timer); timer=null; }
  }

  /* ───────── Events ───────── */
  btnRefresh.addEventListener("click", refresh);
  cbAuto.addEventListener("change", startAuto);
  selTail.addEventListener("change", refresh);
  selDate.addEventListener("change", refresh);
  tbName.addEventListener("change", async ()=>{
    setTitle();
    await loadDates();
    await refresh();
  });

  // Keyboard: Ctrl/Cmd+R to refresh (prevent full reload)
  document.addEventListener("keydown", (e)=>{
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="r"){
      e.preventDefault();
      refresh();
    }
  });

  /* ───────── Init ───────── */
  (async function init(){
    await loadDates();
    await refresh();
    startAuto();
  })();

})();
</script>
</body>
</html>
