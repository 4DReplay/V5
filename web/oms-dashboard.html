<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>4DReplay V5 - Dashboard</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />  
  <!-- common title/style -->
  <script src="/web/oms-common.js"></script>
  <script>
    OMS.initAssets();             // common CSS/JS auto loading
    OMS.applyPageConfig("Dashboard");
    OMS.initActions();            // oms-actions.js auto loading
  </script>
</head>

<body>
  <!-- favicon 404 ë°©ì§€: ì‹¤ì œ ìœ„ì¹˜ì— ë§ì¶° /web/images/... ë„ í•¨ê»˜ ì‹œë„ -->
  <button id="btnFullscreen" class="fullscreen-btn" type="button" title="Toggle fullscreen"
    aria-label="Toggle fullscreen">
    â¤¢
  </button>
  <h1 class="page-title" id="pageTitle"> 
  </h1>
  <!-- ì „ì²´ íƒ€ì´í‹€ ë°”ë¡œ ì•„ë˜ ì¤„ë¡œ ì§„í–‰ ë©”ì‹œì§€ ì¹© ì´ë™ -->
  <div class="page-title-chip-row">
    <span id="titleProgress" class="chip chip-title" role="status" aria-live="polite"></span>
    <button class="btn-secondary" onclick="location.href='/user'">âš™ï¸ User Config</button>
  </div>

  <div class="grid">
    <!-- System card -->
    <section class="card-dashboard-card" id="sysCard">
      <h2>
        <button id="btnSystemTitle" type="button" class="title-btn">
          <span class="title-icon">âš™ï¸</span><span class="title-text">System</span>
        </button>
        <span id="sysPoll" class="chip-poll">poll -</span>
      </h2>
      <div class="ready" id="sysReady">Ready</div>

      <div class="stats-wrapper">
        <div class="actions">
          <button id="btnSysRestart" class="btn-neo btn-green" title="Processes Restart">
            <span class="top">Processes</span>
            <span class="bottom">Restart</span>
          </button>
          <button id="btnSysConnect" class="btn-neo btn-blue" title="Processes Connect"
            data-reconnect="/oms/sys-connect/sequence">
            <span class="top">Processes</span>
            <span class="bottom">Connect</span>
          </button>
        </div>
        <div class="stats stat-merged" id="sysStats">
          <div class="stat-line">
            node : <span id="sysNodes">-</span>, total processes : <span id="sysProcs">-</span>
          </div>
          <div class="stat-line">
            connected : <span id="sysConn">0</span> / running : <span id="sysRun">0</span> / stopped : <span id="sysStop">0</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Camera card -->
    <section class="card-dashboard-card" id="camCard">
      <h2>
        <button id="btnCameraTitle" type="button" class="title-btn">
          <span class="title-icon">ğŸ“¸</span><span class="title-text">Camera</span>
        </button>
        <span id="camPoll" class="chip-poll">poll -</span>
      </h2>
      <div class="ready" id="camReady">Ready</div>
      <div class="stats-wrapper">
        <div class="actions">
          <button id="btnCamRestart" class="btn-neo btn-green" title="Cameras Restart">
            <span class="top">Cameras</span>
            <span class="bottom">Restart</span>
          </button>
          <button id="btnCamConnect" class="btn-neo btn-blue" title="Cameras Connect">
            <span class="top">Cameras</span>
            <span class="bottom">Connect</span>
          </button>
        </div>
        <div class="stats stat-merged" id="camStats">
          <div class="stat-line">
            total cameras : <span id="camTotal">-</span>
          </div>
          <div class="stat-line">
            connected : <span id="camConn">0</span> / on : <span id="camOn">0</span> / off : <span id="camOff">0</span>
          </div>
        </div>

    </section>
  </div>
  <script>

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Progress ë©”ì‹œì§€ ë™ê¸°í™”(oms-systemê³¼ ë™ì¼)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const PROG_LS_KEY = "oms_ra_progress";   // :contentReference[oaicite:0]{index=0}
    let __dashRestartSeenRunning = false;
    let __dashRestartFinishedOnce = false;
    window.__restart_done_once = false;  // ğŸ”¹ ì´ë²ˆ ë¦¬ìŠ¤íƒ€íŠ¸ì—ì„œ done/idle ì²˜ë¦¬í–ˆëŠ”ì§€ ì—¬ë¶€

    const $ = (id) => document.getElementById(id);
    const getTitleChipEl = () => $('titleProgress');
    const getProgressChipEl = () => $('progressChip');

    window.__system_restart = false;  // System ì „ìš© Restarting ë½
    window.__restart_sticky = false;
    window.__restart_hold_until = 0; // ìµœì†Œ ìœ ì§€ì‹œê°„ìš© (ms)
    window.__ignore_done_until = 0;

    async function httpJson(path, init = {}) {
      const res = await fetch(path, { cache: "no-store", ...init });
      const ct = res.headers.get("content-type") || "";
      if (!res.ok) throw new Error(await res.text().catch(() => `HTTP ${res.status}`));
      return ct.includes("application/json") ? res.json() : res.text();
    }

    function buildTaggedMsg(domainId, actionId, text) {
      const domain = ({ 1: 'system', 2: 'camera' })[Number(domainId)] || 'system';
      const action = ({ 1: 'restart', 2: 'connect' })[Number(actionId)] || 'connect';
      const tail = (text == null ? '' : String(text)).trim();
      return `[${domain}][${action}]${tail ? ' ' + tail : ''}`;
    }

    // ì§„í–‰ì¹©/íƒ€ì´í‹€ì¹© ë©”ì‹œì§€ ì´ˆê¸°í™” + ë‹¨ê¸° ë¬´ì‹œ ìœˆë„ìš° ì„¤ì •
    function clearProgressChip({ ignoreDoneMs = 1500 } = {}) {
      try { localStorage.removeItem(PROG_LS_KEY); } catch { }
      const titleEl = getTitleChipEl?.();
      if (titleEl) {
        titleEl.textContent = '';
        titleEl.style.visibility = 'hidden';
        titleEl.setAttribute('aria-hidden', 'true');
      }
      const progEl = getProgressChipEl?.();
      if (progEl) {
        progEl.textContent = '';
        progEl.style.visibility = 'hidden';
      }
      // ì§í›„ì— íŠ€ì–´ ë“¤ì–´ì˜¤ëŠ” ìŠ¤í…Œì¼ "Restart finished"ëŠ” ì ê¹ ë¬´ì‹œ
      window.__ignore_done_until = Date.now() + ignoreDoneMs;
    }

    const SYS_RESTART_TAG = "[System][Restart]";
    const RX_TAG = /\[(?:system\]\s*\[restart|system\s+restart)\]/i;

    function hasSysRestartTag(msg) {
      return RX_TAG.test(String(msg || ""));
    }
    function isRestartDoneMsg(msg) {
      const t = String(msg || "");
      // finished/done/complete ê°€ ë“¤ì–´ì˜¤ë©´ ì¼ë‹¨ "ì™„ë£Œ í›„ë³´"
      const hasDone = /\b(finished|done|complete)\b/i.test(t);
      if (!hasDone) return false;
      // 1) íƒœê·¸ê°€ ê°™ì´ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ ì™„ë£Œ
      if (RX_TAG.test(t)) return true;
      // 2) íƒœê·¸ëŠ” ì—†ì§€ë§Œ í˜„ì¬ System ì¬ì‹œì‘ ì¤‘ì´ë©´ ì´ê²ƒë„ ì™„ë£Œë¡œ ì¸ì •
      if (window.__system_restart || window.__restart_sticky) return true;
      // 3) ê·¸ ì™¸ì—ëŠ” plain ë©”ì‹œì§€ ìª½ì—ì„œ ì²˜ë¦¬
      return false;
    }
    function isRestartingMsg(msg) {
      const t = String(msg || "");
      // íƒœê·¸ê°€ ìˆê³ , finishedë¥˜ê°€ ì•„ë‹ˆë©´ ì „ë¶€ ì§„í–‰ì¤‘ìœ¼ë¡œ ê°„ì£¼
      return RX_TAG.test(t) && !isRestartDoneMsg(t);
    }

    function releaseRestartLockAndRefresh(force = false) {
      // ì‹œìŠ¤í…œ ì¬ì‹œì‘ í”Œë˜ê·¸ë‚˜ ìŠ¤í‹°í‚¤ í”Œë˜ê·¸ê°€ í•˜ë‚˜ë¼ë„ ì¼œì ¸ ìˆì„ ë•Œë§Œ ë™ì‘
      if (!force && !window.__system_restart && !window.__restart_sticky) return;
      // ğŸ”“ ëª¨ë“  ì¬ì‹œì‘ ê´€ë ¨ í”Œë˜ê·¸ í•´ì œ
      window.__system_restart = false;
      window.__restart_sticky = false;
      window.__restart_hold_until = 0;
      // ìƒíƒœ/ìˆ«ì ì¦‰ì‹œ ë°˜ì˜
      try {
        if (typeof window.__dashRefreshSystem === 'function') {
          window.__dashRefreshSystem();
        }
      } catch { }
    }

    function isPlainDoneMsg(msg) {
      const t = String(msg || "");
      if (hasSysRestartTag(t)) return false; // íƒœê·¸ ìˆìœ¼ë©´ plain ì•„ë‹˜
      // ì„œë²„ê°€ "Finished" / "Done" ê°™ì€ ì§§ì€ ë¬¸êµ¬ë§Œ ë³´ë‚´ëŠ” ê²½ìš°ë„ ì²˜ë¦¬
      return /\b(restart\s*finished|restart-all\s*done|all\s*processes\s*restarted|ì¬ì‹œì‘\s*ì™„ë£Œ|finished|done|complete)\b/i.test(t);
    }

    function writeBoth(msg) {

      // restart ì‹œì‘ ë©”ì‹œì§€ì¸ì§€ íŒë³„
      if (isRestartingMsg(msg)) {
        window.__system_restart = true;

        try {
          const sysReady = document.getElementById('sysReady');
          if (sysReady) {
            sysReady.classList.remove('status-ready');
            sysReady.classList.add('status-warn');
            sysReady.innerHTML = '<span class="main">Restartingâ€¦</span>';
          }
        } catch {}

        return;
      }

      // restart ì™„ë£Œ ë©”ì‹œì§€ì¸ì§€ íŒë³„
      if (isRestartDoneMsg(msg)) {
        releaseRestartLockAndRefresh();
        return;
      }

      // ğŸ”’ stale done message ë¬´ì‹œ ë¡œì§ (chip ê´€ë ¨ ì œê±° í›„ì—ë„ ê·¸ëŒ€ë¡œ ìœ ì§€ ê°€ëŠ¥)
      if ((window.__system_restart || window.__restart_sticky) &&
          Date.now() < (window.__ignore_done_until || 0) &&
          isPlainDoneMsg(msg)) {

        const wait = (window.__ignore_done_until || Date.now()) - Date.now();
        window.clearTimeout(window.__late_done_timer);

        window.__late_done_timer = window.setTimeout(() => {
          if (window.__system_restart || window.__restart_sticky) {
            releaseRestartLockAndRefresh();
          }
        }, Math.max(0, wait + 50));

        return;
      }

      // â— ì´ ì•„ë˜ëŠ” chip ê´€ë ¨ ë¡œì§ì´ë¯€ë¡œ ì „ë¶€ ì œê±°ë¨
      // - conn/restart ë¹„êµ
      // - latest ì²˜ë¦¬
      // - prev ì²˜ë¦¬
      // - chipWrite(text)
      // - title chip ì—…ë°ì´íŠ¸
      // - localStorage ì €ì¥
      // ì™„ì „ ì œê±°ë¨
    }

    // chip update
    setInterval(updateChipByLatestState, 1000);
    async function updateChipByLatestState() {
      const [conn, restart] = await Promise.all([
        httpJson("/oms/sys-connect/state").catch(() => null),
        httpJson("/oms/sys-restart/state").catch(() => null)
      ]);

      let latest = null;
      if (conn?.updated_at) latest = { ts: conn.updated_at, msg: conn.message };
      if (restart?.updated_at) {
        if (!latest || restart.updated_at > latest.ts)
          latest = { ts: restart.updated_at, msg: restart.message };
      }
      // prevëŠ” fallback ìš©ë„ë¡œë§Œ ì‚¬ìš©
      const prev = localStorage.getItem("oms_ra_progress") || "";

      // â— latestê°€ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ latest.msg ì‚¬ìš© (ë¹ˆ ë¬¸ìì—´ì´ì–´ë„ OK)
      const finalText = latest ? latest.msg : prev;
      console.log("updateChipByLatestState: ",finalText)

      if (!finalText) 
        return;

      localStorage.setItem("oms_ra_progress", finalText);
      const el = getTitleChipEl();
      if (el) {
        el.textContent = finalText;
        el.style.visibility = "visible";
      }
    }

    // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ìºì‹œë¡œ ì¦‰ì‹œ ë™ê¸°í™”(ìƒˆë¡œê³ ì¹¨ ì§í›„ ëŠê¹€ ë°©ì§€)
    (function syncFromLocalStorageOnce() {
      try {
        const cached = localStorage.getItem(PROG_LS_KEY);
        if (cached && cached.trim()) {
          const titleEl = getTitleChipEl();
          if (titleEl) {
            titleEl.textContent = cached.trim();
            titleEl.style.visibility = 'visible';
            titleEl.setAttribute('aria-hidden', 'false');
          }
          // ğŸ”’ ìºì‹œì— "restart"ê°€ ìˆìœ¼ë©´ ìŠ¤í‹°í‚¤ ì¦‰ì‹œ ì„¸íŒ…
          if (isRestartingMsg(cached)) {
            window.__restart_sticky = true;
            window.__restart_hold_until = Date.now() + 2000;
          }
        }
      } catch { }
    })();

    window.addEventListener("oms:summary", (ev) => {
      const s = ev.detail || {};
      const el = document.getElementById("sysSummary");
      if (!el) return;
      el.textContent =
        `nodes ${s.nodes}, processes ${s.processes}, connected ${s.connected}`;
    });

    // ë‹¤ë¥¸ íƒ­/oms-systemì—ì„œ ê°±ì‹ ë˜ëŠ” ë©”ì‹œì§€ë¥¼ ì‹¤ì‹œê°„ ë°˜ì˜
    window.addEventListener('storage', (e) => {
      if (e.key === PROG_LS_KEY && typeof e.newValue === 'string') {
        writeBoth(e.newValue);
      }
    });

    (function () {
      const PROXY_PREFIX = window.__PROXY_PREFIX__ || "";
      const API = (p) => (p.startsWith("/") ? PROXY_PREFIX + p : p);
      const wait = (ms) => new Promise(r => setTimeout(r, ms));
      const el = {
        sysNodes: document.getElementById('sysNodes'),
        sysProcs: document.getElementById('sysProcs'),
        sysConn: document.getElementById('sysConn'),
        sysRun: document.getElementById('sysRun'),
        sysStop: document.getElementById('sysStop'),
        sysReady: document.getElementById('sysReady'),
        sysPoll: document.getElementById('sysPoll'),
        camTotal: document.getElementById('camTotal'),
        camConn: document.getElementById('camConn'),
        camOn: document.getElementById('camOn'),
        camOff: document.getElementById('camOff'),
        camReady: document.getElementById('camReady'),
        camPoll: document.getElementById('camPoll'),
        btnSysRestart: document.getElementById('btnSysRestart'),
        btnSysConnect: document.getElementById('btnSysConnect'),
        btnCamRestart: document.getElementById('btnCamRestart'),
        btnCamConnect: document.getElementById('btnCamConnect'),
      };

      window.__dashEl = el;

      // â”€â”€ freshness & last-good state (SYSTEM only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let lastSys = null;        // {nodes, processes, connected, running, stopped, ts}
      let lastSysTs = 0;         // latest accepted timestamp (monotonic)
      let preferLSUntil = 0;     // Date.now() ê¸°ì¤€, ì´ ì‹œê° ì´ì „ê¹Œì§€ëŠ” LS(source=oms-system) ìš°ì„ 
      let sysPollTimer = 0;
      let sysPollMs = 3000;      // ê¸°ë³¸ 3s, /oms/statusì˜ heartbeatë¡œ ì¡°ì •
      const pollLabel = () => `poll ${Math.round(sysPollMs / 1000)}s`;
      const nowMs = () => Date.now();


      // ---- helpers ----
      function setStatus(elm, status) {
        const s = String(status || '').toLowerCase();

        // âœ… ëª¨ë“  status-* í´ë˜ìŠ¤ ë¨¼ì € ì œê±°
        elm.classList.remove('status-ready', 'status-warn', 'status-danger', 'status-init');
        if (s === 'ready') {
          elm.classList.add('status-ready');
          elm.innerHTML = 'Ready';
          return;
        }
        // âœ… ìƒˆ ë¶„ê¸°: Needs Check System
        if (s.includes('check system')) {
          elm.classList.add('status-init'); // íŒŒë€ìƒ‰ ê³„ì—´ ìœ ì§€
          elm.innerHTML = '<span class="prefix">Needs</span><span class="main">Check System</span>';
          return;
        }
        if (s.includes('restart')) {
          // Needs Restart â†’ ë¹¨ê°„ìƒ‰
          elm.classList.add('status-danger');
          elm.innerHTML = '<span class="prefix">Needs</span><span class="main">Restart</span>';
        } else {
          // Needs Connect â†’ íŒŒë€ìƒ‰
          elm.classList.add('status-warn');
          elm.innerHTML = '<span class="prefix">Needs</span><span class="main">Connect</span>';
        }
      }


      // 200/204ë§Œ trueë¡œ, ë‚˜ë¨¸ì§€ ì–Œì „íˆ false ë°˜í™˜ (íƒìƒ‰ìš©)
      function isAbsoluteUrl(u) { try { return Boolean(new URL(u)); } catch { return false; } }
      function isHostLike(u) { return /^https?:\/\/[^/]+\/?$/.test(u) || /^[a-z0-9.-]+\/?$/i.test(u); }
      function joinPath(base, tail) {
        const b = base.endsWith("/") ? base.slice(0, -1) : base;
        const t = tail.startsWith("/") ? tail : ("/" + tail);
        return b + t;
      }
      // âœ… ì¶”ê°€: progressChip ì§€ì—° ì¡°íšŒ
      function getProgressChipEl() {
        return document.getElementById('progressChip');
      }

      async function serverHas(path, method = "GET") {
        try {
          if (isAbsoluteUrl(path) || isHostLike(path)) return false;
          const p = path.startsWith("/") ? path : ("/" + path);
          const doFetch = (m) => fetch(API(p), { method: m, cache: "no-store" });

          let res = await doFetch(method === "GET" ? "HEAD" : method);
          if (!res.ok || [400, 405, 501].includes(res.status)) {
            try {
              res = await doFetch("GET");
            } catch (e) {
              console.warn("[serverHas] fallback GET failed", e);
            }
          }
          return res.ok;
        } catch (e) {
          console.warn("[serverHas] failed", e);
          return false;
        }
      }

      // /oms/sys-restart/state í´ë§(í´ë°±): message ê·¸ëŒ€ë¡œ ì‚¬ìš©(í¬ë§· X)  :contentReference[oaicite:1]{index=1}
      let __dashRestartPollTimer = 0;
      async function dashPollRestartState() {
        try {
          const st = await httpJson("/oms/sys-restart/state");

          const state = (st && typeof st === 'object') ? (st.state || "") : "";
          const msg = (st && typeof st === 'object') ? (st.message || "")
            : (typeof st === 'string' ? st : "");

          // 1) running ìƒíƒœë¥¼ í•œ ë²ˆì´ë¼ë„ ë³´ë©´ "ì´ë²ˆ ë¦¬ìŠ¤íƒ€íŠ¸ì—ì„œ ì‹¤ì œë¡œ ëŒê¸° ì‹œì‘í–ˆë‹¤" í‘œì‹œ
          if (state === "running") {
            __dashRestartSeenRunning = true;
            window.__restart_done_once = false;  // âœ… running ëœ¨ë©´ ìƒˆ ë¦¬ìŠ¤íƒ€íŠ¸ ì‚¬ì´í´ ì‹œì‘
          }

          // 2) ìƒˆë¡œ Restart ëˆŒë €ëŠ”ë° ì•„ì§ running ì„ ëª» ë³¸ ìƒíƒœì—ì„œ
          //    state ê°€ done/idle ì´ë©´ â†’ ì§€ë‚œ ë¦¬ìŠ¤íƒ€íŠ¸ì˜ ì°Œêº¼ê¸°ë¼ê³  ë³´ê³  ì™„ì „íˆ ë¬´ì‹œ
          if (!__dashRestartSeenRunning && (state === "done" || state === "idle")) {
            return; // writeBoth ë„, done ì²˜ë¦¬ë„ ì•ˆ í•¨
          }

          // 3) ë©”ì‹œì§€ ì¢…ë¥˜ì— ë”°ë¼ ì²˜ë¦¬ ë¶„ê¸°
          const done = isRestartDoneMsg(msg);
          if (done) {
            // âœ… Finished/done/complete ë¥˜ ë©”ì‹œì§€ëŠ” "í•œ ë²ˆë§Œ" ë°˜ì˜
            if (!__dashRestartFinishedOnce) {
              __dashRestartFinishedOnce = true;
              if (msg) {
                writeBoth(msg);
                try { localStorage.setItem(PROG_LS_KEY, msg); } catch { }
              }
              // ì™„ë£Œ ì‹œì—ëŠ” ë½ í•´ì œ + ìƒíƒœ ê°±ì‹ 
              releaseRestartLockAndRefresh();
            }
          } else {
            // ì§„í–‰ ì¤‘ ë©”ì‹œì§€(preparing, step N/N ë“±)ëŠ” ê³„ì† ì—…ë°ì´íŠ¸
            if (msg) {
              writeBoth(msg);
              try { localStorage.setItem(PROG_LS_KEY, msg); } catch { }
            }
          }

          if (isRestartDoneMsg(msg)) releaseRestartLockAndRefresh();
        } catch { }
        finally {
          __dashRestartPollTimer = window.setTimeout(dashPollRestartState, 700);
        }
      }
      function ensureDashRestartPolling() {
        if (__dashRestartPollTimer) return;
        dashPollRestartState().catch(() => { });
      }
      // ì•¡ì…˜ í˜¸ì¶œ ë³´ì¡°: OMS.Actions ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê±°ë‚˜, í´ë°± REST í˜¸ì¶œ
      async function callAction(kind) {
        // 0) ë²„íŠ¼ data-*ë¡œ ê°•ì œ ê²½ë¡œ ì˜¤ë²„ë¼ì´ë“œ í—ˆìš©
        const overrideReconnect =
          document.getElementById('btnSysConnect')?.dataset?.reconnect?.trim() || "";

        // ì—”ë“œí¬ì¸íŠ¸ íƒìƒ‰: /oms, /oms/sys-restart, /
        const discoverReconnect = async () => {
          // 1) ë² ì´ìŠ¤ í›„ë³´ ì¤‘ "ìƒíƒœ ì—”ë“œí¬ì¸íŠ¸ê°€ ì‹¤ì œë¡œ ì—´ë ¤ìˆëŠ”" ê²ƒë§Œ ì±„íƒ
          const baseRoots = ["/oms", "/"];
          const validBases = [];
          for (const b of baseRoots) {
            const statusPath = joinPath(b, "status");   // => "/oms/status" ë˜ëŠ” "/status"
            const healthPath = joinPath(b, "health");   // => "/oms/health" ë˜ëŠ” "/health"
            if (await serverHas(statusPath) || await serverHas(healthPath)) {
              validBases.push(b);
            }
          }
          // ì•„ë¬´ ë² ì´ìŠ¤ë„ ì—†ìœ¼ë©´ ì¦‰ì‹œ ë¹ˆ ëª©ë¡ ë°˜í™˜ â†’ ë²„íŠ¼ ë¹„í™œì„±í™” íŠ¸ë¦¬ê±°
          if (validBases.length === 0) return [];
          const found = new Set();
          const push = (p) => { if (p && typeof p === "string") found.add(p); };
          const scanText = (t) => {
            // ê²½ë¡œì²˜ëŸ¼ ë³´ì´ëŠ” í† í° ì¤‘ connect/reconnect í¬í•¨ë§Œ ìˆ˜ì§‘
            const rgx = /(\/[A-Za-z0-9_\-\/]+)/g;
            let m; while ((m = rgx.exec(t))) {
              const u = m[1];
              if (/connect|reconnect/i.test(u)) push(u);
            }
          };
          for (const b of validBases) {
            try {
              const raw = await httpJson(b, { method: "GET" });
              if (typeof raw === "object" && raw) {
                // JSON íƒìƒ‰
                const walk = (v) => {
                  if (!v) return;
                  if (typeof v === "string") { if (/connect|reconnect/i.test(v)) push(v); return; }
                  if (Array.isArray(v)) v.forEach(walk);
                  else if (typeof v === "object") Object.values(v).forEach(walk);
                };
                walk(raw);
              } else if (typeof raw === "string") {
                scanText(raw);
              }
            } catch { /* ignore */ }
          }
          const defaults = [];
          for (const b of validBases) {
            defaults.push(
              joinPath(b, "sys-restart/connect"),
              joinPath(b, "sys-restart/connect-all"),
              joinPath(b, "sys-connect/sequence"),
              joinPath(b, "sys-connect/all"),
              joinPath(b, "sys-connect"),
              joinPath(b, "mtd-query")
            );
          }
          return [
            ...found,
            ...defaults
          ];
        };
        // 1) actions ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ëŒ€ê¸° (ìµœëŒ€ 3ì´ˆ)
        try { await (window.__OMS_ACTIONS_LOAD__ || Promise.resolve()); } catch { }
        let tries = 6;
        while (tries-- > 0 && !(window.OMS && (window.OMS.Actions || window.OMS.sysRestart))) {
          await wait(250);
        }
        // 2) ì¤€ë¹„ë˜ì—ˆìœ¼ë©´ ê³µìš© ì•¡ì…˜ í˜¸ì¶œ
        try {
          if (kind === "restart") {
            ensureDashRestartPolling();  // ì§„í–‰ìƒí™© ì‹¤ì‹œê°„ ë°˜ì˜ ì‹œì‘
            if (window.OMS?.Actions?.sysRestart) return window.OMS.Actions.sysRestart();
            if (window.OMS?.sysRestart) return window.OMS.sysRestart();
          } else if (kind === "reconnect") {
            ensureDashRestartPolling();
            // JS ì•¡ì…˜ì´ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ ê³µìš© ì•¡ì…˜ë§Œ ì‚¬ìš©
            if (window.OMS?.Actions?.sysConnect) return window.OMS.Actions.sysConnect();
            if (window.OMS?.sysConnect) return window.OMS.sysConnect();
          }
        } catch (e) {
          // ê³µìš© ì•¡ì…˜ì´ ì¡´ì¬í•˜ì§€ë§Œ ì‹¤íŒ¨ â†’ í´ë°± ì‹œë„
          console.warn("[dash] action failed, fallback", e);
        }
        // 3) ìµœí›„ í´ë°±: ì„œë²„ ì—”ë“œí¬ì¸íŠ¸ ì§ì ‘ í˜¸ì¶œ
        if (kind === "restart") {
          ensureDashRestartPolling();
          await httpJson("/oms/sys-restart/all", { method: "POST" });
          return;
        }
        if (kind === "reconnect") {
          ensureDashRestartPolling();
          await httpJson("/oms/sys-connect/sequence", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ return_partial: true })
          });
          return;
        }
      }

      // ---- comment rules (unchanged logic)
      function commentSystem({ proc, connected, running, stopped }) {
        if (!proc || proc === 0) return 'Needs Check System';
        if (proc === connected) return 'Ready';
        if (stopped > 0) return 'Needs Restart';
        return 'Needs Connect';
      }
      function commentCamera({ cams, connected, on, off }) {
        if (!cams || cams === 0) return 'Needs Check System';
        if (cams === connected) return 'Ready';
        if (off > 0) return 'Needs Restart';
        return 'Needs Connect';
      }

      // ---- System summary helpers (same logic as oms-system) ----
      function ipFromHost(host) {
        const m = String(host || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(host || "");
      }
      function toProcList(status) {
        if (!status) return [];
        if (status.data && typeof status.data === "object") return Object.values(status.data);
        if (Array.isArray(status.processes)) return status.processes;
        if (Array.isArray(status.executables)) return status.executables;
        return [];
      }
      function selectedProcListFromStatus(status) {
        if (!status) return [];
        const execs = Array.isArray(status.executables) ? status.executables : [];
        const procs = Array.isArray(status.processes) ? status.processes : [];
        const dataObjs = (status.data && typeof status.data === "object") ? Object.values(status.data) : [];

        const stateMap = Object.create(null);
        const ingest = (arr) => {
          for (const x of (arr || [])) {
            if (!x) continue;
            const nm = x.name || x.proc || x.id;
            if (!nm) continue;
            stateMap[nm] = { ...(stateMap[nm] || {}), ...x, name: nm };
          }
        };
        ingest(procs);
        ingest(execs);
        ingest(dataObjs);

        const normRunning = (v) => {
          if (typeof v === "boolean") return v;
          const s = String(v || "").trim().toLowerCase();
          return s === "running" || s === "started";
        };

        const base = execs.length ? execs : (procs.length ? procs : dataObjs);
        return base
          .filter(e => e && (e.select !== false))
          .map(e => {
            const nm = e.name || e.proc || e.id;
            const ref = stateMap[nm] || {};
            const running = normRunning(ref.running ?? ref.status ?? e.running ?? e.status);
            return {
              name: nm,
              alias: e.alias || ref.alias || "",
              select: e.select !== false,
              running,
              connection_state: ref.connection_state || e.connection_state || null,
              version: ref.version || e.version,
              version_date: ref.version_date || e.version_date,
            };
          });
      }
      function applyOverlaysForSummary(data) {
        if (!data || !data.extra) return;
        const extra      = data.extra || {};
        const verMap     = extra.versions || {};
        const presdVer   = extra.presd_versions || {};
        const conn       = extra.connected_daemons || {};
        const presdIps   = extra.presd_ips || [];
        const nodes      = Array.isArray(data.nodes) ? data.nodes : [];

        const listFromStatus = toProcList;

        for (const n of nodes) {
          const nodeIp = ipFromHost(n.host);
          const procs = listFromStatus(n.status);
          for (const p of procs) {
            if (!p || !p.name) continue;

            // ë²„ì „ ì˜¤ë²„ë ˆì´ (oms-systemê³¼ ë™ì¼)
            if (p.name === "PreSd") {
              const src =
                presdVer[nodeIp] ||
                (verMap.PreSd && (verMap.PreSd[nodeIp] || (verMap.PreSd.byIp && verMap.PreSd.byIp[nodeIp]))) ||
                null;
              if (src) {
                p.version = src.version || "-";
                p.version_date = src.date || "-";
              } else if (verMap.PreSd && verMap.PreSd.version) {
                p.version = verMap.PreSd.version || "-";
                p.version_date = verMap.PreSd.date || "-";
              }
            } else if (verMap[p.name]) {
              p.version = verMap[p.name].version || p.version || "-";
              p.version_date = verMap[p.name].date || p.version_date || "-";
            }

            // CONNECTED ì˜¤ë²„ë ˆì´ (PCd / PreSd)
            if (conn && conn[p.name] === true) {
              if (p.name === "PreSd") {
                const ipOk = !presdIps.length || presdIps.includes(nodeIp);
                if (ipOk) p.connection_state = "CONNECTED";
              } else {
                p.connection_state = "CONNECTED";
              }
            }
          }
        }
      }
      function effectiveStateOfProc(procObj) {
        if (!procObj) return "STOPPED";
        const running = !!procObj.running;
        const conn = String(procObj.connection_state || "").toUpperCase();
        if (!running) return "STOPPED";
        if (conn === "CONNECTED") return "CONNECTED";
        return "RUNNING";
      }
      function normCamState(v) {
        const s = String(v || '').toLowerCase();
        if (s.includes('video ok') || s.includes('connected') || s.includes('info ok') || s === 'ok') return 'connected';
        if (s === 'on' || s === 'running') return 'on';
        if (s === 'off' || s === 'disconnected' || s === 'not connected' || s === 'failed') return 'off';
        return 'unknown';
      }

      // ---- System stats (/oms/status)
      // ---- System stats (single source of truth w/ freshness guard) ----------
      function renderSystem(sum, label) {
        el.sysNodes.textContent = String(sum.nodes ?? 0);
        el.sysProcs.textContent = String(sum.processes ?? 0);
        el.sysConn.textContent = String(sum.connected ?? 0);
        el.sysRun.textContent = String(sum.running ?? 0);
        el.sysStop.textContent = String(sum.stopped ?? 0);
        const cmt = commentSystem({
          proc: Number(sum.processes || 0),
          connected: Number(sum.connected || 0),
          running: Number(sum.running || 0),
          stopped: Number(sum.stopped || 0),
        });
        // System ë°°ë„ˆëŠ” ë²„íŠ¼-ê¸°ë°˜ ë½(__system_restart) ë˜ëŠ” ë©”ì‹œì§€-ê¸°ë°˜ ìŠ¤í‹°í‚¤ ë½ì„ ëª¨ë‘ ì¡´ì¤‘
        const stick = window.__restart_sticky && (Date.now() < (window.__restart_hold_until || 0));
        if (window.__system_restart || window.__restart_sticky || stick) {
          el.sysReady.classList.remove('status-ready');
          el.sysReady.classList.remove('status-warn');
          el.sysReady.classList.add('status-init');
          el.sysReady.innerHTML = '<span class="main">Restartingâ€¦</span>';
        } else {
          setStatus(el.sysReady, cmt);
        }
        if (label) el.sysPoll.textContent = label;
      }

      function isFresher(candidate) {
        if (!candidate) return false;
        const ts = Number(candidate.ts ?? candidate.seq ?? 0);
        return Number.isFinite(ts) && ts > lastSysTs;
      }

      // =========================
      // Common JSON Request Helpers
      // =========================
      async function GET_JSON(url, opts) {
        const res = await fetch(url, opts || {});
        return await res.json();
      }
      // dashboard ì—ì„œëŠ” SSE ë¥¼ ì“°ì§€ ì•Šì•„ë„ ë˜ë¯€ë¡œ no-op ìœ¼ë¡œ ë‘”ë‹¤.
      function useSseIfNeeded(_resp) {
        // intentionally empty
      }

      function acceptIfFresher(sum, label) {
        if (!sum) return false;
        const norm = {
          nodes: Number(sum.nodes ?? 0),
          processes: Number(sum.processes ?? 0),
          connected: Number(sum.connected ?? 0),
          running: Number(sum.running ?? 0),
          stopped: Number(sum.stopped ?? 0),
          ts: Number(sum.ts ?? sum.seq ?? nowMs()),
        };
        if (!isFresher(norm)) return false;
        lastSys = norm;
        lastSysTs = norm.ts;
        renderSystem(norm, label);
        return true;
      }

      async function refreshSystem() {
        console.log("refreshSystem");
        const label = pollLabel();
        try {
          const s = await GET_JSON("/oms/status", { timeoutMs: 800 });
          if (s && s.summary && typeof s.summary === "object") {
            const sum = s.summary;
            acceptIfFresher({
              nodes:     sum.nodes     ?? 0,
              processes: sum.processes ?? 0,
              connected: sum.connected ?? 0,
              running:   sum.running   ?? 0,
              stopped:   sum.stopped   ?? 0,
              ts: nowMs(),
            }, label);
          } else {
            console.log("refreshSystem - summary null");
            const nodes = Array.isArray(s && s.nodes) ? s.nodes : [];
            acceptIfFresher({
              nodes: nodes.length,
              processes: 0,
              connected: 0,
              running: 0,
              stopped: 0,
              ts: nowMs(),
            }, label);
          }
          // SSE ëŠ” ì„œë²„ ì‘ë‹µ ê°ì²´ ê¸°ì¤€ìœ¼ë¡œë§Œ
          useSseIfNeeded(s);
        } catch (e) {
          console.warn("[dashboard] refreshSystem failed:", e);
        }
      }   

      window.__dashRefreshSystem = refreshSystem;
      // live update from storage/broadcast
      try {
        window.addEventListener("storage", (e) => {
          if (e.key !== "oms_summary" || typeof e.newValue !== "string") return;
          try {
            const sum = JSON.parse(e.newValue);
            if (sum && sum.source === "oms-system") {
              if (acceptIfFresher(sum, pollLabel())) {
                preferLSUntil = nowMs() + 5000;
              }
            }
          } catch { /* ignore */ }
        });
        window.addEventListener("oms:summary", () => { refreshSystem().catch(() => { }); });
      } catch { }

      // ---- Camera stats (/oms/state or local snapshot)
      async function refreshCamera() {
        let raw = null; try { raw = localStorage.getItem("oms_camera_summary"); } catch { }        
        let st = null;
        try {
          st = await GET_JSON("/oms/state");
        } catch (e) {
          console.warn("[dashboard] refreshCamera /oms/state failed:", e);
        }

        let cams = 0, connected = 0, on = 0, off = 0;
        if (st && typeof st.summary === 'object') {
          cams = Number(st.summary.cameras || 0);
          connected = Number(st.summary.connected || 0);
          on = Number(st.summary.on || 0);
          off = Number(st.summary.off || 0);
        } else {
          const list = Array.isArray(st?.cameras) ? st.cameras : [];
          cams = list.length;
          if (Array.isArray(st?.connected_ips)) {
            connected = st.connected_ips.length;
          }
          if (st?.camera_status && typeof st.camera_status === 'object') {
            let c = 0, o = 0, f = 0;
            for (const v of Object.values(st.camera_status)) {
              const n = normCamState(v);
              if (n === 'connected') c++;
              else if (n === 'on') o++;
              else if (n === 'off') f++;
            }
            if (!Array.isArray(st?.connected_ips)) connected = c;
            on = o; off = f;
          }
        }
        el.camTotal.textContent = String(cams || 0);
        el.camConn.textContent = String(connected || 0);
        el.camOn.textContent = String(on || 0);
        el.camOff.textContent = String(off || 0);
        const cc = commentCamera({ cams, connected, on, off });
        setStatus(el.camReady, cc);
        el.camPoll.textContent = "poll 3s";
      }

      try { window.addEventListener("storage", (e) => { if (e.key === "oms_camera_summary") { refreshCamera().catch(() => { }); } }); } catch { }
      try { const camCh = new BroadcastChannel("oms_camera"); camCh.onmessage = (ev) => { const s = ev.data; if (s && s.source === "oms-camera") { refreshCamera().catch(() => { }); } };      } catch { }

      ////////////////////////////////////////////////////////////////////////////
      // System Actions (same API fallbacks)      
      ////////////////////////////////////////////////////////////////////////////
      el.btnSysRestart.onclick = async () => {
        el.btnSysRestart.disabled = true;
        try {
          __dashRestartSeenRunning = false;
          __dashRestartFinishedOnce = false;
          clearProgressChip({ ignoreDoneMs: 2000 });

          // â‘¡ ì‹œìŠ¤í…œ ì¬ì‹œì‘ ë½/ìŠ¤í‹°í‚¤ ë½ ì¦‰ì‹œ ON (ë©”ì‹œì§€ ì˜¤ê¸° ì „ì—ë„ ìœ ì§€)
          window.__system_restart = true;
          window.__restart_sticky = true;
          window.__restart_hold_until = Date.now() + 2000;

          // â‘¢ UI ì¦‰ì‹œ í‘œì‹œ
          el.sysReady.innerHTML = '<span class="main">Restartingâ€¦</span>';
          el.sysReady.classList.remove('status-warn', 'status-danger', 'status-ready');
          el.sysReady.classList.add('status-init');
          // â‘£ ì´í›„ ì›ë˜ ë¡œì§ ìˆ˜í–‰
          await callAction("restart");
        } catch (e) {
          alert("Restart failed: " + (e?.message || e));
        } finally {
          el.btnSysRestart.disabled = false;
        }
      };
      el.btnSysConnect.onclick = async () => {
        el.btnSysConnect.disabled = true;
        try {
          // âœ… Restartì™€ ë™ì¼í•˜ê²Œ, Connect ì‹œì‘ ì „ì— ì§€ë‚œ ì§„í–‰ ë©”ì‹œì§€/ìºì‹œ ì œê±°
          clearProgressChip({ ignoreDoneMs: 1500 });
          // actions ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ëŒ€ê¸°
          try {
            await (window.__OMS_ACTIONS_LOAD__ || Promise.resolve());
          } catch { }

          if (window.OMS?.Actions?.mtdConnect) {
            // oms-system ê³¼ ë™ì¼í•œ mtdConnect ê³µí†µ ì•¡ì…˜ ì‚¬ìš©
            await window.OMS.Actions.mtdConnect();
          } else if (window.OMS?.Actions?.sysConnect) {
            await window.OMS.Actions.sysConnect();
          } else if (window.OMS?.sysConnect) {
            await window.OMS.sysConnect();
          } else {
            console.error("Connect action not available");
            alert("Connect action is not available.");
          }
        } catch (e) {
          console.error("Connect failed", e);
          alert("Connect failed: " + (e?.message || e));
        } finally {
          // ë²„íŠ¼ ë„ˆë¬´ ë¹¨ë¦¬ í’€ë¦¬ëŠ” ê²ƒ ë°©ì§€ìš© ì†ŒëŸ‰ ì§€ì—°
          setTimeout(() => {
            el.btnSysConnect.disabled = false;
          }, 1000);
        }
      };
      
      //////////////////////////////////////////////////////////////////////////
      // Camera Actions (bind to actual OMS.Actions methods)
      //////////////////////////////////////////////////////////////////////////
      (function bindDashboardCameraButtons() {
        // actions.js load ëŒ€ê¸° (ì´ë¯¸ ë¡œë“œë¼ ìˆìœ¼ë©´ ë°”ë¡œ ì§€ë‚˜ê°)
        const wait = window.__OMS_ACTIONS_LOAD__ || Promise.resolve();
        wait.then(() => {
          if (!window.OMS || !OMS.Actions) return;

          const A = OMS.Actions;
          // Restart â†’ cameraRebootAll
          const btnCamRestart = document.getElementById("btnCamRestart");
          if (btnCamRestart && typeof A.cameraRebootAll === "function") {
            btnCamRestart.onclick = A.cameraRebootAll;
          }

          // Connect â†’ cameraConnectAll
          const btnCamConnect = document.getElementById("btnCamConnect");
          if (btnCamConnect && typeof A.cameraConnectAll === "function") {
            btnCamConnect.onclick = A.cameraConnectAll;
          }          
        });
      })();

      // initial + auto refresh
      (async function boot() {
        try { await refreshSystem(); } catch { }
        try { await refreshCamera(); } catch { }
        // SYSTEM: heartbeat ê¸°ë°˜ ì£¼ê¸°(ê¸°ë³¸ 3s). /oms/status ì‘ë‹µì—ì„œ ì¡°ì •ë¨.
        if (!sysPollTimer) {
          sysPollTimer = setInterval(() => { refreshSystem().catch(() => { }); }, sysPollMs);
        }
        setInterval(() => { refreshCamera().catch(() => { }); }, 1000);
        // ì§„í–‰ì¹©: LS ë™ê¸°í™” + ì„œë²„ í´ë°± ë™ì‹œ í™œì„±í™”
        ensureDashRestartPolling();
      })();
    })();
  </script>

  <!-- ì „ì²´í™”ë©´ í† ê¸€ ìŠ¤í¬ë¦½íŠ¸ -->
  <script>
    (function () {
      const btn = document.getElementById('btnFullscreen');
      if (!btn) return;

      function syncIcon() {
        // â¤¢ : ì „ì²´í™”ë©´ ì§„ì… / â¤¡ : ì „ì²´í™”ë©´ í•´ì œ ëŠë‚Œ
        btn.textContent = document.fullscreenElement ? 'â¤¡' : 'â¤¢';
      }

      btn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(() => { });
          }
        } else if (document.exitFullscreen) {
          document.exitFullscreen().catch(() => { });
        }
      });

      document.addEventListener('fullscreenchange', syncIcon);
      syncIcon();
    })();
  </script>

  <script>
    // ê¸°ë³¸ ë² ì´ìŠ¤ ê²½ë¡œ(í•„ìš” ì‹œ ì„œë²„ì— ë§ê²Œ ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥)
    window.__omsConnectBase = window.__omsConnectBase || "/oms/sys-connect";
    // proxy-safe prefix (ìƒë‹¨ ë¡œë”ê°€ ì£¼ì…í•œ ê°’ ì¬ì‚¬ìš©)
    const __PX = window.__PROXY_PREFIX__ || "";
    // "/oms/connect"ì²˜ëŸ¼ ì ˆëŒ€ ê²½ë¡œë©´ í”„ë¡ì‹œ í”„ë¦¬í”½ìŠ¤ë¥¼ ë¶™ì—¬ì£¼ê³ , ì ˆëŒ€ê°€ ì•„ë‹ˆë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    const CONNECT_BASE = window.__omsConnectBase;
    const CONNECT_API = (p) => {
      const tail = p.startsWith("/") ? p : ("/" + p);
      if (CONNECT_BASE.startsWith("/")) return __PX + CONNECT_BASE + tail;
      return CONNECT_BASE + tail;
    };

    let CONN_EVT_SRC = null, CONN_STATE_POLLER = null;

    async function startConnectSSE() {
      stopConnectSSE();
      const bases = await discoverConnectBases();
      if ("EventSource" in window) {
        // stream ìœ„ì¹˜ í›„ë³´: /stream, /connect/stream, /restart/stream ë“±
        const tails = ["/stream", "/connect/stream", "/restart/stream"];
        let es = null;
        for (const b of bases) {
          for (const t of tails) {
            try {
              es = new EventSource((b.startsWith("/") ? (__PX + b) : b) + t);
              // ì²« ì—ëŸ¬ ì‹œ ë‹¤ìŒ í›„ë³´ë¡œ ë„˜ì–´ê°€ë„ë¡ í•¸ë“¤ëŸ¬ ì„¤ì¹˜
              es.onerror = () => { try { es.close(); } catch { }; };
              CONN_EVT_SRC = es;
              break;
            } catch { }
          }
          if (CONN_EVT_SRC) break;
        }
        if (!CONN_EVT_SRC) return startConnectStatePolling(); // SSE ì‹¤íŒ¨ â†’ í´ë§
        const handler = (e) => {
          try {
            const s = JSON.parse(e.data);
            onConnectState(s);
          } catch {
            onConnectState(e.data);
          }
        };
        CONN_EVT_SRC.addEventListener("progress", handler);
        CONN_EVT_SRC.onmessage = handler;
        // event ì´ë¦„ì´ progressê°€ ì•„ë‹ˆì–´ë„ ìˆ˜ì‹ ë˜ê²Œ ëª¨ë‘ ë°”ì¸ë”©
        CONN_EVT_SRC.addEventListener("progress", handler);
        CONN_EVT_SRC.addEventListener("connect", handler);
        CONN_EVT_SRC.onmessage = handler;
        CONN_EVT_SRC.onerror = () => { startConnectStatePolling(); };
      } else {
        startConnectStatePolling();
      }
    }
    function stopConnectSSE() {
      if (CONN_EVT_SRC) { CONN_EVT_SRC.close(); CONN_EVT_SRC = null; }
    }

    function startConnectStatePolling() {
      stopConnectStatePolling();
      CONN_STATE_POLLER = setInterval(async () => {
        try {
          const bases = await discoverConnectBases();
          const tails = ["/state", "/connect/state", "/restart/state"];
          let got = null;
          for (const b of bases) {
            for (const t of tails) {
              try {
                const res = await fetch((b.startsWith("/") ? (__PX + b) : b) + t, { cache: "no-store" });
                if (!res.ok) continue;
                try { got = await res.json(); } catch { try { got = await res.text(); } catch { } }
                if (got) break;
              } catch { }
            }
            if (got) break;
          }
          if (got) onConnectState(got);
        } catch { }
      }, 700);
    }
    function stopConnectStatePolling() {
      if (CONN_STATE_POLLER) { clearInterval(CONN_STATE_POLLER); CONN_STATE_POLLER = null; }
    }

    // ëŒ€ì‹œë³´ë“œìš© ì§„í–‰ ë©”ì‹œì§€ ì“°ê¸°: ê³µí†µ chipWrite + ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ë™ê¸°í™”
    function raWrite(msg, holdSeconds) {
      const text = (msg == null ? "" : String(msg));

      // ê³µí†µ chipWrite ê²½ë¡œ (oms-actions.js)
      try {
        window.OMS?.Actions?.chipWrite?.(text);
      } catch { }

      // ì§„í–‰ ë©”ì‹œì§€ë¥¼ LSì— ì§ì ‘ ìºì‹œí•´ ë‘ë©´ ìƒˆë¡œê³ ì¹¨/ë‹¤ë¥¸ íƒ­ì—ì„œ ë°”ë¡œ ë³µì› ê°€ëŠ¥
      try {
        const trimmed = text.trim();
        if (trimmed) {
          localStorage.setItem(PROG_LS_KEY, trimmed);
        }
      } catch { }
    }

    async function discoverConnectBases() {
      // callActionì˜ discoverReconnect()ì™€ ë™ì¼ í›„ë³´ë¥¼ ì¬ì‚¬ìš©
      const bases = [];
      const override = document.getElementById('btnSysConnect')?.dataset?.reconnect?.trim() || "";
      const fromOverride = override ? [override] : [];
      // ë²„íŠ¼ ì˜¤ë²„ë¼ì´ë“œê°€ ì ˆëŒ€ê²½ë¡œë©´ ê±°ê¸°ì„œ ë² ì´ìŠ¤ ì¶”ì¶œ
      for (const u of fromOverride) {
        const m = String(u).match(/^(.*)\/(connect|reconnect|connect-all|restart\/connect.*)$/i);
        if (m) bases.push(m[1]);
      }
      // ê¸°ë³¸ í›„ë³´
      bases.push("/oms/sys-connect", "/oms/sys-restart", "/oms");
      // ì¤‘ë³µ ì œê±°
      return bases.filter((v, i, a) => a.indexOf(v) === i);
    }

    function onConnectState(evt) {
      const msg = parseSseBody(evt);

      if (msg?.type === "state") {
        updateInfo("connect", msg?.connect ?? "-");
        updateInfo("ip", msg?.ip ?? "-");
        updateInfo("port", msg?.port ?? "-");
        updateInfo("domain", msg?.domain ?? "-");
        updateInfo("version", msg?.version ?? "-");
      }
    }

    function parseSseBody(evt) {
      try {
        if (!evt?.data) return null;
        return JSON.parse(evt.data);
      } catch (e) {
        console.error("parseSseBody failed", e, evt.data);
        return null;
      }
    }

    function finalizeConnectChip(s) {
      stopConnectSSE();
      stopConnectStatePolling();
      if (s && s.message) updateInfo(s.message, 10);
      // í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ í•œë²ˆ ìƒíƒœ ìƒˆë¡œê³ ì¹¨
      // reloadNow && reloadNow({ silent: true });
    }

    // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ì´ë²¤íŠ¸(ê°™ì€ ì˜¤ë¦¬ì§„ì¼ ë•Œë§Œ ë™ì‘)
    window.addEventListener("storage", (e) => {
      if (e.key === PROG_LS_KEY && typeof e.newValue === "string") {
        const chip = document.getElementById("progressChip");
        if (chip) {
          chip.style.visibility = "visible";
          chip.textContent = e.newValue;
        }
      }
    });

    // ë¶€íŒ… ì‹œ: restart ëª¨ë‹ˆí„°ì™€ í•¨ê»˜ connect ëª¨ë‹ˆí„°ë„ ì‹œì‘
    (function bootstrapDashboard() {
      // ê¸°ì¡´ restart ëª¨ë‹ˆí„° ì‹œì‘ í•¨ìˆ˜ê°€ ìˆë‹¤ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
      // startRestartSSE();  // (ì´ë¯¸ ì¡´ì¬í•œë‹¤ê³  ê°€ì •)

      // Connectë„ êµ¬ë… ì‹œì‘
      startConnectSSE();

      // ìºì‹œëœ ì§„í–‰ì¹© ë³µì›(ê°™ì€ ì˜¤ë¦¬ì§„ì¼ ë•Œ)
      try {
        const cached = localStorage.getItem(PROG_LS_KEY);
        if (cached) {
          const el = document.getElementById('titleProgress');
          if (el) {
            el.textContent = cached.trim();
            el.style.visibility = 'visible';
            el.setAttribute('aria-hidden', 'false');
          }
        }
      } catch { }
    })();
  </script>

  <style>
    #dashProgress {
      /* gridì˜ ë³„ë„ ì•„ì´í…œìœ¼ë¡œì„œ 2ë²ˆì§¸ ì»¬ëŸ¼(=Camera) ì•„ë˜ì— ë†“ê¸° */
      grid-column: 2;
      /* ë°ìŠ¤í¬í†±(2ì—´)ì—ì„œëŠ” ì˜¤ë¥¸ìª½ ì—´ì— ìœ„ì¹˜ */
      display: flex;
      justify-content: flex-end;
      /* ìš°ì¸¡ ì •ë ¬ */
      align-items: center;
      margin-top: 10px;
      /* ì¹´ë“œì™€ ê°„ê²© */
      pointer-events: none;
      /* ì¹© ì™¸ ì˜ì—­ì€ í´ë¦­ ì•ˆ ê°€ë¡œì±„ê²Œ */
    }

    /* ê¸°ë³¸: 2ì—´ ê³ ì • */
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      /* â† auto-fit/minmax ì œê±° */
      gap: 20px;
      align-items: start;
    }

    /* âœ… 1ì—´ ì „í™˜ ì„ê³„ê°’ì„ í•œ ë²ˆì— ê°•ì œ (ì›í•˜ëŠ” ê°’ìœ¼ë¡œ ì¡°ì ˆ) */
    @media (max-width: 740px) {

      /* â† í•„ìš”ì— ë§ê²Œ 900~1200 ì‚¬ì´ë¡œ ì¡°ì ˆ */
      .grid {
        grid-template-columns: 1fr;
        /* 1ì—´ ê³ ì • */
      }

      #dashProgress {
        grid-column: 1;
        justify-content: center;
        margin: 8px 0 0;
      }

      #dashProgress .chip {
        width: 100%;
        max-width: none;
      }
    }

    /* ì¹´ë“œ ë‚´ë¶€ ë²„íŠ¼ì„ ì„¸ë¡œë¡œ ìŒ“ê¸° (ì¢ì€ í™”ë©´ì¼ ë•Œ) */
    @media (max-width: 660px) {

      /* í†µê³„/ë²„íŠ¼ ë¸”ë¡ì„ ìœ„â†’ì•„ë˜ë¡œ */
      .stats-wrapper {
        position: static;
        /* ì„¸ë¡œ ë²„ì „ì—ì„œëŠ” ì¹´ë“œ ì•ˆì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ íë¥´ë„ë¡ */
        left: auto;
        right: auto;
        bottom: auto;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 15px;
        margin-top: 15px;  /* READY ë°”ë¡œ ì•„ë˜ë¡œ ë¶™ê²Œ */
      }

      /* ë²„íŠ¼ ì»¨í…Œì´ë„ˆ: í•œ ì¤„ì— í•˜ë‚˜ì”© */
      .actions {
        display: grid;
        grid-template-columns: 1fr;
        /* â† 1ì—´ */
        gap: 10px;
      }

      /* ë²„íŠ¼ì„ ê°€ë¡œí˜•/í’€í­ìœ¼ë¡œ */
      .btn-neo {
        width: 100%;
        /* â† í’€í­ */
        height: 72px;
        /* ì„¸ë¡œ ë†’ì´ ì¶•ì†Œ */
        border-radius: 18px;
        /* ë¼ìš´ë“œ ì™„í™” */
        flex-direction: row;
        /* í…ìŠ¤íŠ¸ë¥¼ ê°€ë¡œë¡œ ìì—°ìŠ¤ëŸ½ê²Œ */
        justify-content: center;
        gap: 10px;
      }

      .btn-neo span.top {
        /* ë³´ì¡° ë¼ë²¨ */
        font-size: 12px;
        font-weight: 800;
      }

      .btn-neo span.bottom {
        /* ë©”ì¸ ë¼ë²¨ */
        font-size: 20px;
        margin-top: 0;
      }

      /* ì„¸ë¡œë¡œ ëŠ˜ì–´ë‚˜ë©° ì¹´ë“œ í•˜ë‹¨ì´ ê°€ë ¤ì§€ì§€ ì•Šê²Œ í•˜ë‹¨ íŒ¨ë”© ë³´ê°•(í•„ìš”ì‹œ) */
      .card {
        padding-bottom: 25px;
        /* ë²„íŠ¼ 2ê°œ ì„¸ë¡œë°°ì¹˜ ë†’ì´ì— ë§ì¶° ì—¬ìœ  */
      }

      /* âœ… í™”ë©´ í¬ê¸° ìƒê´€ì—†ì´, Needs Connect ìƒ‰ìƒì„ CONNECT ë²„íŠ¼ í†¤ìœ¼ë¡œ ê³ ì • */
      #sysReady.status-warn,
      #camReady.status-warn {
        color: var(--board--accent-blue) !important;
      }

    }
  </style>

  <!-- System / Camera ì œëª© â†’ /system, /camera ë¡œ ì´ë™ -->
  <script>
    (function () {
      const origin = location.origin;
      const sysBtn = document.getElementById('btnSystemTitle');
      const camBtn = document.getElementById('btnCameraTitle');

      if (sysBtn) {
        sysBtn.addEventListener('click', function () {
          location.href = origin + '/system';
        });
      }
      if (camBtn) {
        camBtn.addEventListener('click', function () {
          location.href = origin + '/camera';
        });
      }
    })();
  </script>

  <!-- Common Title -->
  <script>
    (function () {
      function applyCommonConfig(cfg) {
        if (!cfg || typeof cfg !== "object") return;

        // ê³µí†µ prefix (ì›í•˜ë©´ ì‚¬ìš©)
        var appName = cfg.appName || "4DReplay";
        var version = cfg.version || "V5";
        var pageCfg = (cfg.pages && cfg.pages.omsDashboard) || {};

        // 1) HTML <title>
        if (pageCfg.htmlTitle) {
          document.title = pageCfg.htmlTitle;
        } else {
          document.title = appName + " " + version + " - Dashboard";
        }

        // 2) í™”ë©´ ë‚´ H1 íƒ€ì´í‹€ + favicon ì´ë¯¸ì§€ prepend
        var h1 = document.getElementById("pageTitle");
        if (h1 && pageCfg.pageTitle) {

          // ê¸°ì¡´ í…ìŠ¤íŠ¸ ìœ ì§€
          h1.textContent = pageCfg.pageTitle;

          // ì•„ì´ì½˜ì´ ì´ë¯¸ ë¶™ì–´ ìˆìœ¼ë©´ ì¤‘ë³µ ì‚½ì… ê¸ˆì§€
          if (!h1.querySelector(".title-icon") && cfg.faviconHref) {
            var img = document.createElement("img");
            img.src = cfg.faviconHref;
            img.className = "title-icon";

            // í…ìŠ¤íŠ¸ í¬ê¸°ì— ìë™ ë§ì¶¤
            img.style.height = "1em";       // í…ìŠ¤íŠ¸ ë†’ì´ì™€ ë™ì¼
            img.style.width = "auto";       // ë¹„ìœ¨ ìœ ì§€
            img.style.verticalAlign = "-0.15em"; // í…ìŠ¤íŠ¸ baselineì— ë§ì¶”ê¸°
            img.style.marginRight = "8px";

            h1.prepend(img);
          }
        }

        // 3) favicon link êµì²´ (ë¸Œë¼ìš°ì € íƒ­ ì•„ì´ì½˜)
        if (cfg.faviconHref) {
          var existing = document.querySelector('link[rel="icon"]');
          if (!existing) {
            existing = document.createElement("link");
            existing.rel = "icon";
            existing.type = "image/x-icon";
            document.head.appendChild(existing);
          }
          existing.href = cfg.faviconHref;

          // ë§Œì•½ Titleì— ì´ë¯¸ ì•„ì´ì½˜ì´ ìˆì—ˆìœ¼ë©´ srcë„ ì—…ë°ì´íŠ¸
          var titleIcon = document.querySelector("#pageTitle .title-icon");
          if (titleIcon) {
            titleIcon.src = cfg.faviconHref;
          }
        }
      }

      function init() {
        // ì´ë¯¸ ë¡œë”©ë¼ ìˆìœ¼ë©´ ë°”ë¡œ ì ìš©
        if (window.OmsCommonConfig) {
          applyCommonConfig(window.OmsCommonConfig);
        }
        // ë‚˜ì¤‘ì— ë¡œë”©ë  ìˆ˜ë„ ìˆìœ¼ë‹ˆ ì´ë²¤íŠ¸ë„ êµ¬ë…
        try {
          window.addEventListener("oms:config-ready", function (e) {
            applyCommonConfig(e.detail || window.OmsCommonConfig || {});
          });
        } catch (e) { /* ì´ë²¤íŠ¸ ë¯¸ì§€ì› ë¸Œë¼ìš°ì €ë©´ ë¬´ì‹œ */ }
      }
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>

</body>
</html>