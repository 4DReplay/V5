<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>OMS LiveView (CCd + MediaMTX WebRTC/HLS, no npm)</title>
  <link rel="icon" type="image/x-icon" href="web/images/4DMain.ico">
  <script>
    (function () {
      const m = location.pathname.match(/^\/proxy\/([^/]+)/);
      const PROXY_PREFIX = m ? "/proxy/" + encodeURIComponent(m[1]) : "";
      const bust = "?v=" + Date.now();

      const CSS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.css",
        "./4d-common-style.css",
      ];
      const JS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.js",
        "./4d-common-style.js",
      ];

      function injectCSS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("link");
        el.rel = "stylesheet";
        el.href = list[i] + bust;
        el.onerror = () => {
          console.warn("[CSS miss]", list[i]);
          injectCSS(list, i + 1);
        };
        document.head.appendChild(el);
      }

      function injectJS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("script");
        el.defer = true;
        el.src = list[i] + bust;
        el.onerror = () => {
          console.warn("[JS miss]", list[i]);
          injectJS(list, i + 1);
        };
        document.head.appendChild(el);
      }

      injectCSS(CSS_CANDIDATES);
      injectJS(JS_CANDIDATES);
    })();
  </script>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- proxy-safe asset loader: works for /proxy/<node>/... and direct port -->
  <script>
    (function () {
      // e.g., /proxy/DMS-1/oms-system.html  =>  /proxy/DMS-1
      const m = location.pathname.match(/^\/proxy\/([^/]+)/);
      const PROXY_PREFIX = m ? "/proxy/" + encodeURIComponent(m[1]) : "";
      const bust = "?v=" + Date.now(); // cache-buster to avoid stale css/js

      const CSS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.css",
        "./4d-common-style.css",
      ];
      const JS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.js",
        "./4d-common-style.js",
      ];

      function injectCSS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("link");
        el.rel = "stylesheet"; el.href = list[i] + bust;
        el.onerror = () => { console.warn("[CSS miss]", list[i]); injectCSS(list, i + 1); };
        document.head.appendChild(el);
      }
      function injectJS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("script");
        el.defer = true; el.src = list[i] + bust;
        el.onerror = () => { console.warn("[JS miss]", list[i]); injectJS(list, i + 1); };
        document.head.appendChild(el);
      }
      injectCSS(CSS_CANDIDATES); injectJS(JS_CANDIDATES);
    })();
  </script>
</head>

<body>
  <div id="root"></div>

  <script>
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       Proxy prefix (OMSê°€ /proxy/<node>/web-liveview.html ë¡œ ì„œë¹„ìŠ¤ë  ë•Œ ì ˆëŒ€ê²½ë¡œ ë³´ì •)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const API_PREFIX = (() => {
      const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
      return m ? `/proxy/${encodeURIComponent(decodeURIComponent(m[1]))}` : "";
    })();
    function withPrefix(path) {
      if (!path || typeof path !== "string") return path;
      if (path.startsWith("/") && !path.startsWith("/proxy/") && API_PREFIX) {
        return API_PREFIX + path;
      }
      return path;
    }
    (function ensureBase() {
      if (!API_PREFIX) return;
      const base = document.createElement("base");
      base.href = API_PREFIX + "/";
      document.head.prepend(base);
    })();
    (function patchFetchForProxy() {
      if (!API_PREFIX) return;
      const orig = window.fetch;
      window.fetch = function (input, init = {}) {
        if (typeof input === "string") return orig(withPrefix(input), init);
        try {
          const u = withPrefix(input.url || "");
          const req = new Request(u, input);
          return orig(req);
        } catch { return orig(input, init); }
      };
    })();

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       Tiny helpers
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const pad = n => (n < 10 ? `0${n}` : `${n}`);
    const ts = () => { const d = new Date(); return d.getFullYear() + pad(d.getMonth() + 1) + pad(d.getDate()) + "_" + pad(d.getHours()) + pad(d.getMinutes()); };
    const randTok = () => `live_${ts()}_${Math.random().toString(36).slice(2, 5)}`;
    const ipToKey = ip => String(ip || "").trim().replaceAll(".", "_");
    const buildPathName = (camIp, pathTpl) => {
      const ip_ = ipToKey(camIp);
      return (pathTpl && pathTpl.includes("{ip_}")) ? pathTpl.replaceAll("{ip_}", ip_).replace(/^\//, "") : `cam_${ip_}`;
    };
    // MediaMTX URL ë¹Œë” (HLS/WebRTC)
    const buildWebrtcUrl = ({ gwHost, webrtcPort, pathName }) => `http://${gwHost}:${webrtcPort}/${pathName}`;
    const buildHlsUrl = ({ gwHost, hlsPort, pathName, useHlsPrefix = false }) =>
      `http://${gwHost}:${hlsPort}/${useHlsPrefix ? "hls/" : ""}${pathName}/index.m3u8`;

    // ê³µí†µ fetch ëž˜í¼
    async function api(path, init = {}) {
      const res = await fetch(withPrefix(path), { cache: "no-store", mode: "cors", credentials: "include", ...init });
      const ct = res.headers.get("content-type") || "";
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        try { if (ct.includes("application/json")) { const j = JSON.parse(t); throw new Error(j?.error || j?.message || t || `HTTP ${res.status}`); } }
        catch { }
        throw new Error(t || `HTTP ${res.status}`);
      }
      return ct.includes("application/json") ? res.json() : res.text();
    }

    // MTd ì¤‘ê³„ (OMS -> MTd -> CCd)
    function esOpen(url, opts = { withCredentials: true }) { return new EventSource(withPrefix(url), opts); }
    async function mtdConnect({ host, port, message, wait = 15, onSseLine }) {
      const payload = { host, port, message, wait_sec: wait };
      const token = message?.Token || "";
      let es = null, stopTimer = null;
      function close() { try { es && es.close(); } catch { } if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; } }

      if (token && typeof onSseLine === "function") {
        es = esOpen(`/oms/subscribe?token=${encodeURIComponent(token)}`, { withCredentials: true });
        es.onmessage = ev => {
          let obj = ev.data; try { obj = JSON.parse(ev.data); } catch { }
          onSseLine(obj);
          if (stopTimer) clearTimeout(stopTimer);
          stopTimer = setTimeout(close, 1200);
        };
        es.onerror = () => close();
      }
      const r = await api(`/oms/mtd-connect?wait=${encodeURIComponent(wait)}`, {
        method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload), keepalive: true
      });
      return r?.response ?? r;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       React App
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const { useEffect, useMemo, useRef, useState } = React;

    function App() {
      // CCd / MediaMTX ê²Œì´íŠ¸ì›¨ì´ ì„¤ì •
      const [ccdHost, setCcdHost] = useState("10.82.104.210");
      const [ccdPort, setCcdPort] = useState(19765);
      const [dmpdip, setDmpdip] = useState("10.82.104.210");

      const [gwHost, setGwHost] = useState("127.0.0.1");
      const [hlsPort, setHlsPort] = useState(8888);
      const [webrtcPort, setWPort] = useState(8889);
      const [pathTpl, setPathTpl] = useState("cam_{ip_}"); // MediaMTX path name
      const [useHlsPrefix, setUseHlsPrefix] = useState(false); // /hls/ ê²½ë¡œ ì“°ëŠ” ì»¤ìŠ¤í…€ í”„ë¡ì‹œ í™˜ê²½ì¼ ë•Œë§Œ ì²´í¬

      // ëª¨ë“œ/í”Œë ˆì´ì–´
      const [opMode, setOpMode] = useState("Live");   // Live | Run
      const [player, setPlayer] = useState("WebRTC"); // WebRTC | HLS
      const [msg, setMsg] = useState("");
      const [status, setStatus] = useState("idle");   // idle / connecting / live / error / warn

      // ì¹´ë©”ë¼
      const [cameraIp, setCameraIp] = useState("");
      const [activeList, setActiveList] = useState("10.1.1.107,10.1.1.108");
      const [inactiveList, setInactiveList] = useState("10.1.1.109,10.1.1.110");
      const [timeMs, setTimeMs] = useState(1500);
      const [synctimeMs, setSynctimeMs] = useState(2000);
      const [synclimit, setSynclimit] = useState(10);
      const [syncskip, setSyncskip] = useState(false);

      // ìž¬ìƒ URL ë° í•­ëª©
      const [playUrl, setPlayUrl] = useState("");
      const videoRef = useRef(null);
      const hlsRef = useRef(null);

      // HLS ì´ˆê¸°í™”/í•´ì œ
      useEffect(() => {
        if (player !== "HLS") { if (hlsRef.current) { hlsRef.current.destroy(); hlsRef.current = null; } return; }
        const video = videoRef.current;
        if (!video) return;
        if (!playUrl) { video.removeAttribute("src"); return; }

        if (Hls.isSupported()) {
          const hls = new Hls({ enableWorker: true, lowLatencyMode: true });
          hlsRef.current = hls;
          hls.attachMedia(video);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => hls.loadSource(playUrl));
          hls.on(Hls.Events.ERROR, (_e, data) => {
            setStatus("warn"); setMsg(`HLS: ${data?.details || data?.type || "unknown"}`);
          });
        } else {
          // Safariì¼ ê²½ìš° natively m3u8 ê°€ëŠ¥
          video.src = playUrl;
          video.play().catch(() => { });
        }
        return () => { if (hlsRef.current) { hlsRef.current.destroy(); hlsRef.current = null; } };
      }, [player, playUrl]);

      const pathName = useMemo(() => buildPathName(cameraIp || "0.0.0.0", pathTpl), [cameraIp, pathTpl]);
      const computedWebrtc = useMemo(() => buildWebrtcUrl({ gwHost, webrtcPort, pathName }), [gwHost, webrtcPort, pathName]);
      const computedHls = useMemo(() => buildHlsUrl({ gwHost, hlsPort, pathName, useHlsPrefix }), [gwHost, hlsPort, pathName, useHlsPrefix]);

      const setLiveUrl = () => {
        if (player === "WebRTC") {
          setPlayUrl(computedWebrtc); // iframeì—ì„œ ì‚¬ìš©
        } else {
          setPlayUrl(computedHls);    // video(HLS.js)ì—ì„œ ì‚¬ìš©
        }
      };

      const appendLog = (title, obj) => {
        const ta = document.getElementById("rawlog");
        const line = `\n\n=== ${title} @ ${new Date().toISOString()} ===\n` + JSON.stringify(obj, null, 2);
        ta.value += line;
        ta.scrollTop = ta.scrollHeight;
      };

      async function handleLiveStart() {
        try {
          setStatus("connecting"); setMsg("Live ì‹œìž‘ ìš”ì²­â€¦");
          if (!cameraIp) { setStatus("error"); setMsg("Camera IPë¥¼ ìž…ë ¥í•˜ì„¸ìš”."); return; }

          // 1) ëª¨ë“  ì¹´ë©”ë¼ Run ìƒíƒœ í™•ë³´ (Action: run)
          const tkRun = `1104_${Date.now()}_run`;
          const reqRun = {
            Section1: "Camera", Section2: "Operation", Section3: "Live",
            SendState: "request", From: "4DOMS", To: "CCd", Action: "run",
            Token: tkRun, DMPDIP: dmpdip
          };
          appendLog("REQ Live(run, all)", reqRun);
          const respRun = await mtdConnect({ host: ccdHost, port: ccdPort, message: reqRun, wait: 12 });
          appendLog("RESP Live(run, all)", respRun);
          if ((respRun?.ResultCode ?? 0) !== 1000) { throw new Error(respRun?.ErrorMsg || `Live(run) ì‹¤íŒ¨ (${respRun?.ResultCode})`); }

          // 2) íŠ¹ì • ì¹´ë©”ë¼ Run (Action: set), Cameras=[IP]
          const tkSet = randTok();
          const reqSet = {
            Section1: "Camera", Section2: "Operation", Section3: "Live",
            SendState: "request", From: "4DOMS", To: "CCd", Action: "set",
            Token: tkSet, DMPDIP: dmpdip, Cameras: [cameraIp]
          };
          appendLog("REQ Live(set, single)", reqSet);
          const respSet = await mtdConnect({ host: ccdHost, port: ccdPort, message: reqSet, wait: 12 });
          appendLog("RESP Live(set, single)", respSet);
          if ((respSet?.ResultCode ?? 0) !== 1000) { throw new Error(respSet?.ErrorMsg || `Live(set) ì‹¤íŒ¨ (${respSet?.ResultCode})`); }

          // 3) í”Œë ˆì´ URL í™•ì •
          setLiveUrl();
          setStatus("live"); setMsg(player === "WebRTC" ? "WebRTC ì—°ê²°" : "HLS ì—°ê²°");
        } catch (e) {
          setStatus("error"); setMsg(e?.message || "Live ì‹œìž‘ ì‹¤íŒ¨");
        }
      }

      async function handleRunStart() {
        try {
          setStatus("connecting"); setMsg("Run ì‹œìž‘ ìš”ì²­â€¦");
          const parse = s => s.split(",").map(x => x.trim()).filter(Boolean);
          const act = parse(activeList); const inact = parse(inactiveList);
          if (act.length === 0) { setStatus("error"); setMsg("active ë¦¬ìŠ¤íŠ¸ì— 1ê°œ ì´ìƒ í•„ìš”"); return; }
          const tk = randTok();
          const req = {
            Section1: "Camera", Section2: "Operation", Section3: "Run",
            SendState: "request", From: "4DPD", To: "CCd", Action: "run",
            Token: tk, Streaming: true,
            Status: { time: Number(timeMs) || 1500, synctime: Number(synctimeMs) || 2000, syncskip: Boolean(syncskip), synclimit: Number(synclimit) || 10, active: act, inactive: inact },
            delay: act.map(ip => ({ ip, delay: 0 }))
          };
          appendLog("REQ Run", req);
          const resp = await mtdConnect({ host: ccdHost, port: ccdPort, message: req, wait: 15 });
          appendLog("RESP Run", resp);
          if ((resp?.ResultCode ?? 0) !== 1000) { throw new Error(resp?.ErrorMsg || `Run ì‹¤íŒ¨ (${resp?.ResultCode})`); }
          // ë¯¸ë¦¬ë³´ê¸°: ì²« active ì¹´ë©”ë¼
          if (!cameraIp && act.length) setCameraIp(act[0]);
          setLiveUrl();
          setStatus("live"); setMsg("Run ì„±ê³µ");
        } catch (e) {
          setStatus("error"); setMsg(e?.message || "Run ì‹œìž‘ ì‹¤íŒ¨");
        }
      }

      async function handleStop() {
        try {
          setMsg("Stop ìš”ì²­â€¦");
          const tk = `stop_${Date.now()}`;
          const cams = (opMode === "Live" && cameraIp) ? [cameraIp] : [];
          const req = {
            Section1: "Camera", Section2: "Operation", Section3: "Stop",
            SendState: "request", From: (opMode === "Live" ? "4DOMS" : "4DPD"),
            To: "CCd", Action: "run", Token: tk, DMPDIP: dmpdip, Cameras: cams
          };
          appendLog("REQ Stop", req);
          const resp = await mtdConnect({ host: ccdHost, port: ccdPort, message: req, wait: 8 });
          appendLog("RESP Stop", resp);
          if ((resp?.ResultCode ?? 0) !== 1000) { throw new Error(resp?.ErrorMsg || `Stop ì‹¤íŒ¨ (${resp?.ResultCode})`); }
          setPlayUrl(""); setStatus("idle"); setMsg("ì¢…ë£Œ");
        } catch (e) {
          setStatus("error"); setMsg(e?.message || "Stop ì‹¤íŒ¨");
        }
      }

      // í”Œë ˆì´ì–´ íƒ­ ë°”ê¾¸ë©´ URL ìž¬ê³„ì‚°
      useEffect(() => { if (status === "live") { setLiveUrl(); } }, [player, pathName, gwHost, hlsPort, webrtcPort, useHlsPrefix]);

      return (
        React.createElement(React.Fragment, null,
          React.createElement("div", { className: "row", style: { justifyContent: "space-between" } },
            React.createElement("h2", null, "ðŸŽ¥ OMS LiveView"),
            React.createElement("span", { className: `status ${status}` }, status.toUpperCase())
          ),

          /* â”€ CCd / MediaMTX ì„¤ì • â”€ */
          React.createElement("div", { className: "card" },
            React.createElement("div", { className: "grid" },
              React.createElement("div", null,
                React.createElement("label", null, "CCd Host"),
                React.createElement("input", { value: ccdHost, onChange: e => setCcdHost(e.target.value.trim()) })
              ),
              React.createElement("div", null,
                React.createElement("label", null, "CCd Port"),
                React.createElement("input", { value: ccdPort, onChange: e => setCcdPort(parseInt(e.target.value || "0") || 19765) })
              ),
              React.createElement("div", null,
                React.createElement("label", null, "DMPDIP"),
                React.createElement("input", { value: dmpdip, onChange: e => setDmpdip(e.target.value.trim()) })
              ),
              React.createElement("div", null,
                React.createElement("label", null, "Operation"),
                React.createElement("select", { value: opMode, onChange: e => setOpMode(e.target.value) },
                  React.createElement("option", null, "Live"),
                  React.createElement("option", null, "Run")
                )
              )
            ),
            React.createElement("div", { className: "help", style: { marginTop: 6 } },
              "Live â†’ From=4DOMS/Action=set Â· Run â†’ From=4DPD/Action=run"
            )
          ),

          /* â”€ í”Œë ˆì´ì–´ ì„ íƒ â”€ */
          React.createElement("div", { className: "card" },
            React.createElement("div", { className: "tabbar" },
              React.createElement("div", { className: `tab ${player === "WebRTC" ? "active" : ""}`, onClick: () => setPlayer("WebRTC") }, "WebRTC (ì €ì§€ì—°, :8889)"),
              React.createElement("div", { className: `tab ${player === "HLS" ? "active" : ""}`, onClick: () => setPlayer("HLS") }, "HLS (í˜¸í™˜, :8888)"),
              React.createElement("span", { className: "right help" }, msg)
            ),
            React.createElement("div", { className: "row", style: { alignItems: "end" } },
              React.createElement("div", null,
                React.createElement("label", null, "Gateway Host"),
                React.createElement("input", { value: gwHost, onChange: e => setGwHost(e.target.value.trim()) })
              ),
              player === "HLS" ?
                React.createElement("div", null,
                  React.createElement("label", null, "HLS Port"),
                  React.createElement("input", { value: hlsPort, onChange: e => setHlsPort(parseInt(e.target.value || "0") || 8888) })
                )
                :
                React.createElement("div", null,
                  React.createElement("label", null, "WebRTC Port"),
                  React.createElement("input", { value: webrtcPort, onChange: e => setWPort(parseInt(e.target.value || "0") || 8889) })
                ),
              React.createElement("div", { style: { minWidth: "260px", flex: 1 } },
                React.createElement("label", null, "Path Template"),
                React.createElement("input", { value: pathTpl, onChange: e => setPathTpl(e.target.value) }),
                React.createElement("div", { className: "help" }, "ì˜ˆ) cam_{ip_}  â†’  10.82.104.11 âŸ¶ cam_10_82_104_11")
              ),
              player === "HLS" && React.createElement("label", { style: { marginBottom: 0 } },
                React.createElement("input", { type: "checkbox", checked: useHlsPrefix, onChange: e => setUseHlsPrefix(e.target.checked) }),
                "  ê²½ë¡œì— ",
                React.createElement("code", null, "/hls/"),
                " ì ‘ë‘ ì‚¬ìš©"
              )
            ),
            React.createElement("div", { className: "urlbar", style: { marginTop: "8px" } },
              React.createElement("div", { className: "url" },
                "URL: ",
                player === "WebRTC" ? computedWebrtc : computedHls
              ),
              React.createElement("a", { className: "link", href: (player === "WebRTC" ? computedWebrtc : computedHls), target: "_blank", rel: "noreferrer" }, "ìƒˆ íƒ­ ì—´ê¸°")
            ),
            React.createElement("div", { className: "aspect", style: { marginTop: 8 } },
              player === "WebRTC"
                ? React.createElement("iframe", { src: playUrl || computedWebrtc })
                : React.createElement("video", { ref: videoRef, controls: true, playsInline: true, muted: true, autoPlay: true })
            )
          ),

          /* â”€ Live / Run ì»¨íŠ¸ë¡¤ â”€ */
          React.createElement("div", { className: "card" },
            opMode === "Live"
              ? React.createElement(React.Fragment, null,
                React.createElement("div", { className: "row" },
                  React.createElement("div", { style: { minWidth: "260px", flex: 1 } },
                    React.createElement("label", null, "Camera IP"),
                    React.createElement("input", { placeholder: "10.82.104.11", value: cameraIp, onChange: e => setCameraIp(e.target.value.trim()) })
                  ),
                  React.createElement("button", { onClick: handleLiveStart, disabled: !cameraIp }, "Live On"),
                  React.createElement("button", { className: "secondary", onClick: handleStop }, "Live Off")
                )
              )
              : React.createElement(React.Fragment, null,
                React.createElement("div", { className: "row" },
                  React.createElement("div", { style: { flex: 1 } },
                    React.createElement("label", null, "Active IPs (,ë¡œ êµ¬ë¶„)"),
                    React.createElement("input", { value: activeList, onChange: e => setActiveList(e.target.value) })
                  ),
                  React.createElement("div", { style: { flex: 1 } },
                    React.createElement("label", null, "Inactive IPs"),
                    React.createElement("input", { value: inactiveList, onChange: e => setInactiveList(e.target.value) })
                  )
                ),
                React.createElement("div", { className: "row", style: { marginTop: 8 } },
                  React.createElement("div", null, React.createElement("label", null, "time(ms)"), React.createElement("input", { value: timeMs, onChange: e => setTimeMs(parseInt(e.target.value || "0") || 1500) })),
                  React.createElement("div", null, React.createElement("label", null, "synctime(ms)"), React.createElement("input", { value: synctimeMs, onChange: e => setSynctimeMs(parseInt(e.target.value || "0") || 2000) })),
                  React.createElement("div", null, React.createElement("label", null, "synclimit"), React.createElement("input", { value: synclimit, onChange: e => setSynclimit(parseInt(e.target.value || "0") || 10) })),
                  React.createElement("label", { style: { marginBottom: 0 } },
                    React.createElement("input", { type: "checkbox", checked: syncskip, onChange: e => setSyncskip(e.target.checked) }),
                    " syncskip"
                  ),
                  React.createElement("button", { onClick: handleRunStart }, "Run Start"),
                  React.createElement("button", { className: "secondary", onClick: handleStop }, "Stop")
                )
              ),
            React.createElement("div", { className: "help", style: { marginTop: 6 } }, "ìƒíƒœ: ", msg || "-")
          ),

          /* â”€ ë¡œê·¸ â”€ */
          React.createElement("div", { className: "card" },
            React.createElement("div", { className: "muted" }, "Raw Logs (ìš”ì²­/ì‘ë‹µ)"),
            React.createElement("textarea", { id: "rawlog", readOnly: true })
          )
        )
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));
  </script>
</body>

</html>