<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>4DReplay OMS - Orchestrator Manager</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <link rel="icon" href="images/4dmain.ico" type="image/x-icon">
  <link rel="alternate icon" href="images/4dmain.ico">
  <style>
    :root{
      --bg:#0b0f14; --fg:#eef2f7; --muted:#94a3b8;
      --th:#0f172a; --line:#243045;
      --row-run:#0e2416;
      --row-stop:#171a1e;
      --badge-ok:#1f9d48;
      --badge-bad:#b83a3a;
      --btn:#1e40af; --btn2:#334155;
    }
    html,body{height:100%}
    body{background:var(--bg);color:var(--fg);font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px}
    h2{font-size:32px;margin:0 0 14px;display:flex;align-items:center;gap:8px}
    h2 small{font-size:14px;color:var(--muted)}
    .toolbar{display:flex;gap:10px;margin:8px 0 16px;align-items:center;flex-wrap:wrap}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid var(--line);padding:10px}
    th{background:var(--th);text-align:left}
    tr.running td{ background:var(--row-run); }
    tr.other   td{ background:var(--row-stop); }
    .pill{display:inline-block;padding:6px 12px;border-radius:999px;border:1px solid;line-height:1;font-weight:500;letter-spacing:.3px;background:transparent}
    .badge-ok { color:#22c55e;border-color:var(--badge-ok); }
    .badge-bad{ color:#f87171;border-color:var(--badge-bad); }
    .muted{color:var(--muted)}
    button{background:var(--btn);color:#fff;border:0;border-radius:14px;padding:8px 14px;cursor:pointer;display:inline-flex;align-items:center;gap:6px;transition:filter .2s ease}
    .btn-secondary{ background:var(--btn2); }
    button:hover{ filter:brightness(1.08) }
    .toolbar button{ border-radius:12px; padding:10px 16px }
    a.node{color:#93c5fd;text-decoration:none}
    a.node:hover{text-decoration:underline}
    .spacer{flex:1}
    .chip{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);background:#0f172a;border-radius:12px;padding:6px 10px;color:var(--fg)}
    #busyMsg{margin-left:8px;opacity:.9}
    #err{display:none;margin:8px 0;padding:10px;border-radius:8px;background:#3b0d0d;border:1px solid #ef4444;color:#ffe0e0;white-space:pre-wrap}
  </style>
</head>
<body>
  <h2>
    <span>4DReplay V5 - OMs Control</span>
    <small id="meta"></small>
  </h2>

  <div class="toolbar">
    <button id="btnConfig" class="btn-secondary">ğŸ“ Config Editor</button>
    <button id="btnConnect" class="btn-secondary">ğŸ§© Connect</button>
    <button id="omsRestartAll" class="btn-secondary">âŸ³ Restart All</button>
    <button id="btnReload" class="btn-secondary">ğŸ”„ Reload</button>    
    <small id="busyMsg" style="margin-left:10px;opacity:.9"></small>
    <span class="spacer"></span>
    <label class="chip">
      <input type="checkbox" id="cbOnlySelected">
      only selected
    </label>
    <span class="chip" id="hb">poll -</span>
  </div>

  <div id="err"></div>

  <table id="grid">
    <thead>
      <tr>
        <th>Node</th>
        <th>Process</th>
        <th>Version</th>
        <th>PID</th>
        <th>Status</th>
        <th>Last RC</th>
        <th>Exe</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <p class="muted" style="margin-top:10px">
    Tip: â€œLogsâ€ can be accessed through the OMS proxy (<code>/proxy/&lt;node&gt;/â€¦</code>).
  </p>

<script>

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ for Debug  â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
window.addEventListener("error", (ev)=>{
  try{ showErr("JS error: " + ev.message); }catch{}
});

window._omsSentLog = window._omsSentLog || [];
function _logSent(rec){
  try{
    window._omsSentLog.push(rec);
    if (window._omsSentLog.length > 500) window._omsSentLog.shift();
    // í•„ìš”í•˜ë©´ ì½˜ì†” ë¡œê·¸
    // console.debug('[OMS SENT]', rec);
  }catch(e){}
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Proxy helper â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const __PROXY_PREFIX__ = (() => {
  const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
  return m ? `/proxy/${encodeURIComponent(decodeURIComponent(m[1]))}` : "";
})();
(function ensureBase(){
  if (!__PROXY_PREFIX__) return;
  const base = document.createElement("base");
  base.href = __PROXY_PREFIX__ + "/";
  document.head.prepend(base);
})();
(function patchFetch(){
  if (!__PROXY_PREFIX__) return;
  const orig = window.fetch;
  window.fetch = function(input, init){
    let url = input;
    if (typeof input !== "string" && input && input.url) url = input.url;
    if (typeof url === "string") {
      if (url.startsWith("/") && !url.startsWith("/proxy/")) url = __PROXY_PREFIX__ + url;
    }
    if (typeof input !== "string" && input && input.url) {
      return orig(new Request(url, input), init);
    }
    return orig(url, init);
  };
})();
async function api(path, init = {}){
  const res = await fetch(path, { cache: "no-store", ...init });
  const ct = res.headers.get("content-type") || "";
  const isJson = ct.includes("application/json");
  if (!res.ok) {
    let msg = `HTTP ${res.status}`;
    try {
      if (isJson) {
        const j = await res.json();
        msg = j?.error || j?.message || JSON.stringify(j);
      } else {
        msg = (await res.text()) || msg;
      }
    } catch {}
    throw new Error(msg);
  }
  return isJson ? res.json() : res.text();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const TBody = document.querySelector("#grid tbody");
const HB    = document.getElementById("hb");
const META  = document.getElementById("meta");
const BTN   = document.getElementById("btnReload");
const CB_ONLY_SELECTED = document.getElementById("cbOnlySelected");
const OMS_BTN_RESTART_ALL = document.getElementById("omsRestartAll");
const BUSY  = document.getElementById("busyMsg");
const ERRBOX= document.getElementById("err");
const BTN_CONFIG = document.getElementById("btnConfig");
const BTN_CONNECT = document.getElementById("btnConnect");
let lastData = null;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ for Communication  â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

// ğŸ”¹ Connect ì´í›„ ë°›ì•„ì˜¨ ë²„ì „ ìºì‹œ: { "<DaemonName>": { version:"x.y.z", date:"..." } }
const VERSION_CACHE = Object.create(null);
const VERSION_CACHE_META = Object.create(null); // { [daemon]: { ts: number, ok: boolean, tries: number } }
const delay = (ms)=> new Promise(r=>setTimeout(r, ms));

// ğŸ”¹ KNOWN_DAEMONS ë²”ìœ„ í™•ì¥ (PreSd, PostSd ì‚­ì œ)
const KNOWN_DAEMONS = new Set(["AId","AMd","CCd","CMd","EMd","GCd","PCd","SCd","SPd"]);

function _makeToken(){
  const s = Date.now().toString(36);
  const r = Math.random().toString(36).slice(2,5);
  const hh = String(new Date().getHours()).padStart(2,"0");
  const mm = String(new Date().getMinutes()).padStart(2,"0");
  const ss = String(new Date().getSeconds()).padStart(2,"0");
  return `${hh}${mm}_${Date.now()}_${r}`;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ send helper â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function sendMessageToDaemon(message, hostOverride = null, portOverride = 19765){
  const target = hostOverride ? { host: hostOverride } : pickMTdTarget();
  if (!target || !target.host) {
    console.warn("sendMessageToDaemon: MTd target not found");
    showErr?.("No MTd node detected for sending message.");
    return { error: "no-target" };
  }
  const host = hostOverride || target.host;
  const port = portOverride || 19765;

  const startedAt = Date.now();
  try{
    const res = await api("/oms/mtd-connect", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ host, port, message })
    });
    _logSent({
      when: new Date(startedAt).toISOString(),
      target: `${host}:${port}`,
      to: message?.To,
      ok: true
    });
    return res;
  }catch(e){
    _logSent({
      when: new Date(startedAt).toISOString(),
      target: `${host}:${port}`,
      to: message?.To,
      ok: false,
      error: e?.message || String(e)
    });
    showErr?.("SEND error: " + (e?.message || e));
    return { error: e?.message || String(e) };
  }
}

function pickMTdTarget(){
  // lastData.nodes[*].status ì•ˆì—ì„œ name === "MTd" ì¸ í”„ë¡œì„¸ìŠ¤ë¥¼ ê°€ì§„ ë…¸ë“œ ì„ íƒ
  if (!lastData || !Array.isArray(lastData.nodes)) return null;
  for (const n of lastData.nodes){
    const st = n.status;
    const arr = (st && st.data && typeof st.data==="object") ? Object.values(st.data)
              : (Array.isArray(st.processes) ? st.processes
              : (Array.isArray(st.executables) ? st.executables : []));
    if (!arr) continue;
    if (arr.some(p => p && p.name === "MTd")){
      return { nodeName: n.name, host: n.host, port: n.port || 51050, procName: "MTd" };
    }
  }
  return null;
}

function markRowConnected(nodeName, procName){
  const rows = document.querySelectorAll("#grid tbody tr");
  for (const tr of rows){
    const actCell = tr.querySelector("td:last-child [data-node]");
    if (!actCell) continue;
    const node = actCell.getAttribute("data-node");
    const proc = actCell.getAttribute("data-proc");
    if (node === nodeName && proc === procName){
      // 3ë²ˆì§¸(td index 3) Status ì…€: RUNNING/STOPPED ë±ƒì§€ê°€ ë“¤ì–´ìˆìŒ
      const statusCell = tr.children[3];
      if (!statusCell) return;
      statusCell.innerHTML = `<span class="pill" style="border-color:#22c55e;color:#22c55e">CONNECT</span>`;
      // í–‰ ë°°ê²½ë„ ëŸ¬ë‹ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€
      tr.className = "running";
      break;
    }
  }
}

function buildMTDConnectMessage(dmpdIp, daemonList) {
  const allowed = ["EMd", "CCd", "SCd", "GCd", "PCd"];

  // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ëª¬ ì œê±°
  const filteredList = Object.fromEntries(
    Object.entries(daemonList).filter(([k]) => allowed.includes(k))
  );

  return {
    Section1: "mtd",
    Section2: "connect",
    Section3: "",
    SendState: "request",
    From: "4DOMS",
    To: "MTd",
    Token: _makeToken(),
    Action: "set",
    DMPDIP: dmpdIp,
    DaemonList: filteredList
  };
}

function buildDaemonListFromView() {
  const out = {};
  if (!lastData || !Array.isArray(lastData.nodes)) return out;

  const useOnly = !!(CB_ONLY_SELECTED && CB_ONLY_SELECTED.checked);

  for (const node of lastData.nodes) {
    const all = toProcList(node.status);
    const shown = useOnly ? all.filter(p => p && p.select === true) : all;

    for (const p of shown) {
      const name = String(p?.name || "").trim();
      if (!name) continue;

      if (!out[name]) out[name] = node.host; // ë°ëª¬ ì´ë¦„ -> í•´ë‹¹ ë…¸ë“œì˜ IP
    }
  }
  return out;
}

function buildVersionMsg(from, to, extra = {}){
  return {
    Section1: "Daemon",
    Section2: "Information",
    Section3: "Version",
    SendState: "request",
    Token: _makeToken(),
    From: from,   // "4DOMS"
    To: to,       // e.g. "CCd"
    Action: "set",
    ...extra
  };
}

async function requestVersionOnce(host, mtdPort, daemonName, daemonHost = null, attempt = 1){
  const extra = (daemonName === "PreSd")
    ? { DMPDIP: host }
    : {};
  const msg = buildVersionMsg("4DOMS", daemonName, extra);
  const startedAt = Date.now();
  try{
    const r = await api("/oms/mtd-connect", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ host, port: mtdPort, message: msg })
    });
    const resp = r.response || r;
    if (Number(resp?.ResultCode) !== 1000) throw new Error(resp?.ErrorMsg || "ResultCode != 1000");

    const v = resp?.Version?.[daemonName];
    VERSION_CACHE[daemonName] = {
      version: v?.version ? String(v.version) : "-",
      date: v?.date ? String(v.date) : "-"
    };
    VERSION_CACHE_META[daemonName] = { ts: Date.now(), ok: true, tries: attempt };

    // ì „ì†¡ ë¡œê·¸(í”„ë¡ íŠ¸ ë¯¸ë‹ˆ ë¡œê·¸) - í•„ìš” ì‹œ í™•ì¸ìš©
    _logSent({
      when: new Date(startedAt).toISOString(),
      target: `${host}:${mtdPort}`,
      to: daemonName,
      ok: true,
      tries: attempt
    });
    return true;
  } catch (e){
    VERSION_CACHE_META[daemonName] = { ts: Date.now(), ok: false, tries: attempt };
    _logSent({
      when: new Date(startedAt).toISOString(),
      target: `${host}:${mtdPort}`,
      to: daemonName,
      ok: false,
      error: (e && e.message) || String(e),
      tries: attempt
    });

    // ì¬ì‹œë„ 2íšŒê¹Œì§€
    if (attempt < 2){
      await delay(200 + Math.random()*200); // ì§§ì€ backoff
      return requestVersionOnce(host, mtdPort, daemonName, daemonHost, attempt+1);
    }
    return false;
  }
}

async function fetchAllVersions(daemonList, mtdHost){
   const mtdPort = 19765;
   const order = ["MTd", ...Object.keys(daemonList).filter(d => d !== "MTd")];
   for (const daemon of order){
    const daemonHost = daemonList[daemon] || null; // buildDaemonListFromViewì—ì„œ ì±„ìš´ host
    await requestVersionOnce(mtdHost, mtdPort, daemon, daemonHost);
    await delay(120); // MTd ì²˜ë¦¬ ì—¬ìœ 
  }
}
function refreshVersionCellInline(daemonName){
  const rows = document.querySelectorAll("#grid tbody tr");
  for (const tr of rows){
    const procCell = tr.children[1];
    if (!procCell) continue;
    const nameText = (procCell.textContent || "").split("\n")[0].trim();
    if (nameText === daemonName){
      const verCell = tr.children[2];
      const v = VERSION_CACHE[daemonName];
      verCell.innerHTML = v
        ? `${escapeHtml(v.version||"-")}<br><span class="muted">${escapeHtml(v.date||"-")}</span>`
        : `<span class="muted">-<br>-</span>`;
      // âŒ break ì œê±°: ê°™ì€ ë°ëª¬ì´ ì—¬ëŸ¬ ë…¸ë“œì— ìˆì„ ìˆ˜ ìˆìŒ
    }
  }
}

document.getElementById("btnConnect").addEventListener("click", async ()=>{
  const target = pickMTdTarget();
  if (!target){
    return showErr ? showErr("No MTd node detected.") : alert("No MTd node detected.");
  }

  // 1ï¸âƒ£ í™”ë©´ ê¸°ì¤€ DaemonList êµ¬ì„± (ëª¨ë“  visible process ê¸°ì¤€)
  const daemonList = buildDaemonListFromView();
  if (Object.keys(daemonList).length === 0){
    return showErr ? showErr("No known daemons (EMd/SCd/CCd/GCd/SPd/PCd) visible.") 
                  : alert("No known daemons visible.");
  }
  const dmpdIp = guessMgmtIP(target.host);   // ê´€ë¦¬ IP ì¶”ì •, ë¡œì»¬ì´ë©´ MTd IPë¡œ fallback
  const keys = Object.keys(daemonList);
  if (keys.length === 0){
    return showErr ? showErr("No daemon processes visible to connect.") : alert("No daemon processes visible to connect.");
  }

  // 1) MTdì— ë¨¼ì € connect
  const mtdMessage = buildMTDConnectMessage(dmpdIp, daemonList);
  try{
    setBusy?.(true, "CONNECT...");
    const r = await api("/oms/mtd-connect", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        host: target.host,
        port: 19765,
        message: mtdMessage
      })
    });
    const resp = r.response;

    const okCode = Number(resp?.ResultCode) === 1000;
    const list = resp?.DaemonList || {};
    const allOk = Object.values(list).every(v => v && String(v.Status||"").toUpperCase()==="OK");

    if (okCode && allOk){
      markRowConnected(target.nodeName, target.procName);

      // 3ï¸âƒ£ MTd connect ì„±ê³µ í›„ â†’ ê° ë°ëª¬ ë²„ì „ ìš”ì²­ (PreSdëŠ” DMPDIP í¬í•¨)
      await fetchAllVersions(daemonList, target.host);

      setBusy?.(false, "CONNECTED. Versions cached. Press Reload to display.");
    } else {
      const err = resp?.ErrorMsg || JSON.stringify(resp||{});
      setBusy?.(false);
      showErr("CONNECT failed: " + err);
    }
  }catch(e){
    setBusy?.(false);
    showErr("CONNECT error: " + (e.message||e));
  }
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ timeouts â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const DEFAULT_REQ_TIMEOUT = 180000;
const ACTION_TIMEOUTS = { start:180000, stop:180000, restart:300000 };

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function setBusy(flag, msg = ""){
  OMS_BTN_RESTART_ALL.disabled = flag;
  if (BTN_CONFIG) BTN_CONFIG.disabled = flag;
  if (BTN_CONNECT) BTN_CONNECT.disabled = flag;
  BUSY.textContent = msg || "";
}
function showErr(msg){ ERRBOX.style.display="block"; ERRBOX.textContent = msg; }
function clearErr(){ ERRBOX.style.display="none"; ERRBOX.textContent=""; }
function guessMgmtIP(fallback){
  const h = (location.hostname || "").trim();
  // ë¡œì»¬ í˜¸ìŠ¤íŠ¸ë©´ fallback ì‚¬ìš©(MTd ë…¸ë“œ IP ë“±)
  if (!h || h === "localhost" || h === "127.0.0.1") return fallback;
  return h;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function countProcs(nodes, useOnly){
  let total = 0, shown = 0;
  for (const node of (nodes || [])){
    const all = toProcList(node.status);
    total += all.length;
    const sel = useOnly ? all.filter(p => p && p.select === true) : all;
    shown += sel.length;
  }
  return { shown, total };
}

(function initOnlySelected(){
  const qs = new URLSearchParams(location.search);
  const has = qs.has("only");
  const v = (qs.get("only")||"").trim().toLowerCase();
  let init = has ? ["selected","true","1","yes","on"].includes(v) : true;
  CB_ONLY_SELECTED.checked = init;
  CB_ONLY_SELECTED.addEventListener("change", ()=> render(lastData));
})();
const onlySelected = () => !!CB_ONLY_SELECTED.checked;

function toProcList(status){
  if (!status) return [];
  if (status.data && typeof status.data === "object") return Object.values(status.data);
  if (Array.isArray(status.processes))   return status.processes;
  if (Array.isArray(status.executables)) return status.executables;
  return [];
}
function nodeCellHtml(node, procIdx, perNodeTotal){
  const linkHref = `/proxy/${encodeURIComponent(node.name)}/dms-control.html`;
  const title = node.alias || node.name;
  const ndx = (typeof procIdx==="number" && typeof perNodeTotal==="number")
    ? ` (${procIdx+1}/${perNodeTotal})` : "";
  return `
    <a class="node" href="${linkHref}" target="_blank" title="Open DMS Control">${title}</a>
    <br><span class="muted">${node.host}:${node.port}${ndx}</span>
  `;
}

function escapeHtml(s){
  return String(s)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
    .replace(/'/g,"&#39;");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Alias ë³´ê°•ìš©: config(JSON5) íŒŒì„œ & ìºì‹œ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function parseJsonLike(text){
  // strip /* */ comments
  text = text.replace(/\/\*[\s\S]*?\*\//g, "");
  // strip // comments (respecting quotes is overkill here; it's fine for our configs)
  text = text.split("\n").map(line=>{
    const i = line.indexOf("//");
    return i>=0 ? line.slice(0,i) : line;
  }).join("\n");
  // add quotes for simple unquoted keys: key: value
  text = text.replace(/(^|[\s,{])([A-Za-z_][A-Za-z0-9_]*)\s*:/g, '$1"$2":');
  // remove trailing commas
  text = text.replace(/,\s*([}\]])/g, "$1");
  return JSON.parse(text);
}
// nodeName -> { name: alias }
const aliasCache = new Map();
async function ensureNodeAliasMap(nodeName){
  if (aliasCache.has(nodeName)) return aliasCache.get(nodeName);
  try{
    const raw = await api(`/proxy/${encodeURIComponent(nodeName)}/config`);
    const cfg = typeof raw === "string" ? parseJsonLike(raw) : raw;
    const map = {};
    if (cfg && Array.isArray(cfg.executables)){
      for (const it of cfg.executables){
        if (!it || !it.name) continue;
        const al = (it.alias || "").trim();
        if (al) map[String(it.name)] = al;
      }
    }
    aliasCache.set(nodeName, map);
    return map;
  }catch(_){
    const empty = {};
    aliasCache.set(nodeName, empty);
    return empty;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Row ë Œë” â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function buildRow(node, proc, nodeHtmlCached){
  const tr = document.createElement("tr");
  const running = !!proc.running;
  tr.className = running ? "running" : "other";
  const exeShort = (proc.exe||proc.path||"").split(/[\\/]/).slice(-2).join("/");
  const badge = running ? `<span class="pill badge-ok">RUNNING</span>` : `<span class="pill badge-bad">STOPPED</span>`;
  const nameText  = proc.name || "-";
  const aliasText = (proc._aliasResolved || proc.alias || "").trim();
  const nameHtml  = aliasText
  ? `${escapeHtml(nameText)}<br><span class="muted">${escapeHtml(aliasText)}</span>`
  : escapeHtml(nameText);
  // ğŸ”¹ Version -> 1st row : version, 2nd row : date
  const verInfo = VERSION_CACHE[nameText];
  const verHtml = verInfo
    ? `${escapeHtml(verInfo.version || "-")}<br><span class="muted">${escapeHtml(verInfo.date || "-")}</span>`
    : `<span class="muted">-<br>-</span>`;

  tr.innerHTML = `
    <td>${nodeHtmlCached || nodeCellHtml(node)}</td>
    <td>${nameHtml}</td>
    <td>${verHtml}</td>
    <td>${proc.pid ?? "-"}</td>
    <td>${badge}</td>
    <td>${(proc.last_rc ?? proc.last_exit_code ?? "-")}</td>
    <td class="muted" title="${proc.path||proc.exe||""}">${exeShort || "-"}</td>
    <td>
      <button data-a="start"   data-node="${node.name}" data-proc="${proc.name}">Start</button>
      <button class="btn-secondary" data-a="stop"  data-node="${node.name}" data-proc="${proc.name}">Stop</button>
      <button class="btn-secondary" data-a="restart" data-node="${node.name}" data-proc="${proc.name}">Restart</button>
      <button class="btn-secondary" data-a="logs"  data-node="${node.name}" data-proc="${proc.name}">ğŸ“œ Logs</button>
    </td>`;
  return tr;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ render â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function render(data){
  if(!data) return;
  lastData = data;
  HB.textContent = `poll ${data.heartbeat_interval_sec||"-"}s`;
  const useOnly = onlySelected();
  const c = countProcs(data.nodes, useOnly);
  META.textContent = `nodes: ${data.nodes?.length ?? 0}, processes: ${c.shown}`;

  TBody.innerHTML = "";

  const nodesArr = (data.nodes || []);
  for (let i=0; i<nodesArr.length; i++){
    const node = nodesArr[i];
    const status = node.status;
    const all = toProcList(status);
    const shownList = useOnly ? all.filter(p => p && p.select === true) : all;

    // alias ë¯¸ë™ë´‰ ë…¸ë“œë©´, 1íšŒ alias ë§µì„ í™•ë³´í•´ì„œ ì£¼ì…
    let aliasMap = null;
    if (shownList.some(p => p && !p.alias)){
      aliasMap = await ensureNodeAliasMap(node.name);
      for (const p of shownList){
        if (p && !p.alias){
          const al = aliasMap[p.name];
          if (al) p._aliasResolved = al; // í‘œì‹œìš© ì„ì‹œ í•„ë“œ
        }
      }
    }

    if (!status || (all.length === 0 && shownList.length === 0)){
      const tr = document.createElement("tr");
      tr.className = "other";
      tr.innerHTML = `
        <td>${nodeCellHtml(node, 0, 0)}</td>
        <td colspan="6" class="muted">unreachable</td>`;
      TBody.appendChild(tr);
      continue;
    }

    const nodeHtml = nodeCellHtml(node, i, nodesArr.length);
    if (shownList.length === 0){
      const tr = document.createElement("tr");
      tr.className = "other";
      tr.innerHTML = `
        <td>${nodeCellHtml(node, 0, 0)}</td>
        <td colspan="6" class="muted">no selected processes</td>`;
      TBody.appendChild(tr);
      continue;
    }

    const perNodeTotal = shownList.length;
    for (let j = 0; j < shownList.length; j++){
      const p = shownList[j];
      const nodeHtmlPerRow = nodeCellHtml(node, j, perNodeTotal);
      TBody.appendChild(buildRow(node, p, nodeHtmlPerRow));
    }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ bulk helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function looksOk(r) {
  if (r && typeof r === "object") return r.ok !== false && !r.error;
  const s = String(r || "").toLowerCase();
  return /ok|success|done|started|stopped|restarted/.test(s) && !/error|fail/.test(s);
}
async function apiWithTimeout(path, init = {}, timeoutMs = DEFAULT_REQ_TIMEOUT){
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  try { return await api(path, { ...init, signal: ctrl.signal }); }
  finally { clearTimeout(t); }
}
async function tryNodeActionBulkEndpoint(nodeName, action, timeoutMs = DEFAULT_REQ_TIMEOUT) {
  const url = `/proxy/${encodeURIComponent(nodeName)}/${action}`;
  try {
    const r = await apiWithTimeout(url, { method: "POST" }, timeoutMs);
    return { ok: looksOk(r), msg: (r && r.msg) ? r.msg : (typeof r === "string" ? r : "OK") };
  } catch (e) {
    const msg = (e.message || "").toLowerCase();
    if (msg.includes("not found") || msg.includes("404")) return { ok: false, msg: "__FALLBACK__" };
    return { ok: false, msg: e.message || String(e) };
  }
}
function verbOf(action){
  if (action.startsWith("start")) return "start";
  if (action.startsWith("stop"))  return "stop";
  return "restart";
}
async function getProcStatus(nodeName, procName){
  const st = await api(`/proxy/${encodeURIComponent(nodeName)}/status`);
  const list =
    (st && st.data && typeof st.data === "object") ? Object.values(st.data) :
    (Array.isArray(st.processes)   ? st.processes :
     Array.isArray(st.executables) ? st.executables : []);
  return list.find(p => p && p.name === procName) || null;
}
async function waitForState(nodeName, procName, desiredRunning, totalTimeoutMs, pollEveryMs=2000){
  const start = Date.now();
  while (Date.now() - start < totalTimeoutMs){
    try{
      const s = await getProcStatus(nodeName, procName);
      if (s && !!s.running === !!desiredRunning) return { ok: true };
    }catch(_){}
    await new Promise(r => setTimeout(r, pollEveryMs));
  }
  return { ok: false, msg: "poll timeout" };
}

/* ì„ íƒ ë°˜ì˜ëœ í”„ë¡œì„¸ìŠ¤ ëª©ë¡ */
function procNamesForNode(node){
  const arr = toProcList(node.status);
  const filtered = onlySelected() ? arr.filter(p => p && p.select === true) : arr;
  return filtered.map(p => p.name).filter(Boolean);
}

async function doNodeActionByLoop(nodeName, action, names, timeoutMs = DEFAULT_REQ_TIMEOUT, onProgress = null) {
  const verb = verbOf(action);
  const procs = Array.isArray(names) ? names.slice() : [];
  if (!procs.length) return { okCount:0, failCount:0, ok:false, msg:"no selected processes" };

  let okCount = 0, failCount = 0, lastMsg = "OK";
  const perProcBudget = Math.max(20000, Math.floor(timeoutMs / Math.max(1, procs.length)));

  for (const p of procs) {
    try {
      try{
        await apiWithTimeout(
          `/proxy/${encodeURIComponent(nodeName)}/${verb}/${encodeURIComponent(p)}`,
          { method: "POST" },
          perProcBudget
        );
      }catch(_){}
      const wantRunning = (verb !== "stop");
      const waited = await waitForState(nodeName, p, wantRunning, perProcBudget);
      if (waited.ok) okCount++; else { failCount++; lastMsg = waited.msg || "wait failed"; }
    } catch (e) {
      failCount++; lastMsg = e.message || String(e);
    } finally {
      if (typeof onProgress === "function") onProgress(1);
    }
  }
  return { okCount, failCount, ok: failCount === 0, msg:lastMsg };
}

async function runAllOnEveryNode(action) {
  clearErr();
  if (!lastData || !Array.isArray(lastData.nodes)) { showErr("No nodes."); return; }

  const label = action.toUpperCase();
  const verbTimeout = ACTION_TIMEOUTS[verbOf(action)] ?? DEFAULT_REQ_TIMEOUT;

  const perNode = lastData.nodes.map(n => ({ nodeName: n.name, procs: procNamesForNode(n) }));
  const totalProcs = perNode.reduce((s, x) => s + x.procs.length, 0);
  if (!totalProcs) { showErr("No target processes."); return; }

  let done = 0, totalOk = 0, totalFail = 0;
  const bump = (n = 1) => { done += n; setBusy(true, `${label}-ALL... (${done}/${totalProcs})`); };

  setBusy(true, `${label}-ALL... (0/${totalProcs})`);

  const jobs = perNode.map(({ nodeName, procs }) => (async () => {
    if (procs.length === 0) return;
    try{
      const bulk = await tryNodeActionBulkEndpoint(nodeName, action, verbTimeout);
      if (bulk.ok){
        totalOk += procs.length;
        bump(procs.length);
        return;
      }
      if (bulk.msg === "__FALLBACK__"){
        const r = await doNodeActionByLoop(nodeName, action, procs, verbTimeout, bump);
        totalOk  += r.okCount;
        totalFail+= r.failCount;
        return;
      }
      totalFail += procs.length;
      bump(procs.length);
    }catch(e){
      totalFail += procs.length;
      bump(procs.length);
    }
  })());

  await Promise.allSettled(jobs);

  setBusy(false, `${label}-ALL done: ${totalOk} ok, ${totalFail} failed (total ${totalProcs})`);

  try { render(await api("/oms/status")); } catch (e) { console.error(e); }
}


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ wireup â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.getElementById("omsRestartAll").addEventListener("click", () => runAllOnEveryNode("restart-all"));
document.getElementById("btnReload").addEventListener("click", async ()=> {
  try { setBusy(true, "RELOAD..."); clearErr(); render(await api("/oms/status")); }
  catch(e){ showErr(e.message||e); }
  finally{ setBusy(false); }
});
if (BTN_CONFIG){
  BTN_CONFIG.addEventListener("click", ()=> { location.href = "oms-config.html"; });
}

const TBodyEl = document.querySelector("#grid tbody");
TBodyEl.addEventListener("click", async (ev)=>{
  const b = ev.target.closest("button"); if(!b) return;
  const act=b.dataset.a, node=b.dataset.node, proc=b.dataset.proc;
  try{
    if(act==="logs"){
      const url = `/web/log-viewer.html?node=${encodeURIComponent(node)}&name=${encodeURIComponent(proc)}`;
      window.open(url, "_blank"); return;
    }
    clearErr(); setBusy(true, `${act.toUpperCase()} ${node}/${proc}...`);
    await api(`/proxy/${encodeURIComponent(node)}/${act}/${encodeURIComponent(proc)}`,{ method: "POST" });
    const want = (act !== "stop");
    await waitForState(node, proc, want, ACTION_TIMEOUTS[act] ?? DEFAULT_REQ_TIMEOUT);
    setBusy(false, `${act.toUpperCase()} done: ${node}/${proc}`);
    render(await api("/oms/status"));
  }catch(e){
    setBusy(false);
    showErr(`${act.toUpperCase()} failed: ${node}/${proc} - ${e.message||e}`);
  }
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ polling â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function tick(){
  try{
    const data = await api("/oms/status");
    await render(data);
  }catch(e){
    console.error(e);
    showErr("Failed to load status: " + (e.message || e));
  }
}
tick();
setInterval(tick, 2000);
</script>
</body>
</html>
