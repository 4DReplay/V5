<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <!-- common title/style -->
  <script src="/web/oms-common.js"></script>
  <script>
    OMS.initAssets();             // common CSS/JS auto loading
    OMS.applyPageConfig("System");
    OMS.initActions();            // oms-actions.js auto loading
  </script>
</head>

<!----------------------------------------------------------------------------------
BODY
------------------------------------------------------------------------------------>
<body>
  <h2 class="page-title">
    <span id="pageTitle"></span>
    <small id="meta"></small>
  </h2>
  
<!-- TOOLBAR -->
  <div class="toolbar">
    <button id="btnDashboard">üìä Dashboard</button>
    <span class="divider"></span>
    <button id="btnSysRestart" class="btn-secondary">‚ü≥ Restart All</button>
    <span class="divider"></span>
    <button id="btnSysConnect" class="btn-secondary">üîå Connect</button>
    <span class="divider"></span>
    <button id="btnSysConfig" class="btn-secondary">üìù Config Editor</button>
    <button id="btnSysReload" class="btn-secondary">üîÑ Reload</button>    
    <span class="divider"></span>
    <button id="btnSysLogs" class="btn-secondary">üìú Logs</button>
    <span class="spacer"></span>    
    <span class="chip" id="hb">poll -</span>
  </div>
<!-- MESSAGE CHIP -->
  <div class="chip-row">
      <span id="stateChip" class="chip"></span>
      <span id="messageChip" class="chip" role="status" aria-live="polite"></span>
  </div>
  <div id="err">    
  </div>
  <table id="grid">
    <thead>
      <tr>
        <th>Node</th>
        <th>Process</th>
        <th>Version</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <p class="muted" style="margin-top:10px">
    Tip: Clicking the title of each node allows you to manage the system.
  </p>  
  <script>
    const DEBUG = false;
    const TBody = document.querySelector("#grid tbody");
    const HB = document.getElementById("hb");
    const META = document.getElementById("meta");
    const ERR = document.getElementById("err");
    const STATE = document.getElementById("stateChip");
    const MESSAGE = document.getElementById("messageChip");
    
    const BTN_DASHBOARD   = document.getElementById("btnDashboard");
    const BTN_CONFIG      = document.getElementById("btnSysConfig");
    const BTN_SYS_RESTART = document.getElementById("btnSysRestart");
    const BTN_SYS_CONNECT = document.getElementById("btnSysConnect");
    const BTN_SYS_RELOAD  = document.getElementById("btnSysReload");      
    const BTN_SYS_LOGS = document.getElementById("btnSysLogs");  

    /* ‚îÄ‚îÄ ÏßÑÌñâ Î©îÏãúÏßÄ/Ï∫êÏãúÎ•º ÏôÑÏ†ÑÌûà ÎπÑÏö∞Îäî helper ‚îÄ‚îÄ */
    function clearProgressChip() {
      MESSAGE.textContent = "";
      MESSAGE.style.visibility = "hidden";
    }

    let lastData = null;
    let OMS_ALIAS_MAP = {};
    let POLLER = null;
    let POLL_MS = 3000;

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Proxy-safe API prefix (works with /proxy/<node>/‚Ä¶) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const __PROXY_PREFIX__ = (() => {
      const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
      return m ? "/proxy/" + encodeURIComponent(decodeURIComponent(m[1])) : "";
    })();
    function api(path, init = {}) {
      const PFX = (typeof window !== "undefined" && window.__OMS_API_PREFIX__) || __PROXY_PREFIX__ || "";
      const url = (typeof path === "string" && path.startsWith("/")) ? (PFX + path) : path;
      return fetch(url, { cache: "no-store", ...init }).then(async (res) => {
        const ct = res.headers.get("content-type") || "";
        const isJson = ct.includes("application/json");
        const body = isJson ? await res.json().catch(() => ({})) : await res.text().catch(() => "");
        if (!res.ok) throw new Error(isJson ? (body.error || ("HTTP " + res.status)) : (body || ("HTTP " + res.status)));
        return body;
      });
    }

    function showErr(m) { ERR.style.display = "block"; ERR.textContent = m; }
    function clearErr() { ERR.style.display = "none"; ERR.textContent = ""; }

    function setBusy(on) {
      BTN_SYS_RELOAD.disabled = !!on;
      BTN_CONFIG.disabled = !!on;
      BTN_SYS_RESTART.disabled = !!on;
      BTN_SYS_CONNECT.disabled = !!on;
    }

    function startPolling(ms) {
      if (typeof ms === "number" && isFinite(ms) && ms > 0) {
        POLL_MS = ms;
      }
      if (POLLER) clearInterval(POLLER);
      POLLER = setInterval(() => {
        reloadNow({ silent: true }).catch(() => {});
      }, POLL_MS);
      if (DEBUG) console.debug("[OMS] poll started:", POLL_MS, "ms");
    }
    function stopPolling() {
      if (POLLER) {
        clearInterval(POLLER);
        POLLER = null;
      }
    }
    function toProcList(status) {
      if (!status) return [];
      if (status.data && typeof status.data === "object") return Object.values(status.data);
      if (Array.isArray(status.processes)) return status.processes;
      if (Array.isArray(status.executables)) return status.executables;
      return [];
    }
    // ÏÑ†ÌÉù ÎåÄÏÉÅ ÌîÑÎ°úÏÑ∏Ïä§ Î¶¨Ïä§Ìä∏ (dms-system Í∑úÏπôÍ≥º ÎèôÏùºÌïòÍ≤å executables.select=true Í∏∞Ï§Ä)
    function selectedProcList(status) {
      if (!status) return [];
      const execs = Array.isArray(status.executables) ? status.executables : [];
      const procs = Array.isArray(status.processes) ? status.processes : [];
      const dataObjs = (status.data && typeof status.data === "object") ? Object.values(status.data) : [];

      const stateMap = Object.create(null);
      const ingest = (arr) => {
        for (const x of (arr || [])) {
          if (!x) continue;
          const nm = x.name || x.proc || x.id;
          if (!nm) continue;
          stateMap[nm] = { ...(stateMap[nm] || {}), ...x, name: nm };
        }
      };
      ingest(procs);
      ingest(execs);
      ingest(dataObjs);

      const normRunning = (v) => {
        if (typeof v === "boolean") return v;
        const s = String(v || "").trim().toLowerCase();
        return s === "running" || s === "started";
      };

      const base = execs.length ? execs : (procs.length ? procs : dataObjs);
      return base
        .filter(e => e && (e.select !== false))
        .map(e => {
          const nm = e.name || e.proc || e.id;
          const ref = stateMap[nm] || {};
          const running = normRunning(ref.running ?? ref.status ?? e.running ?? e.status);
          return {
            name: nm,
            alias: e.alias || ref.alias || "",
            select: e.select !== false,
            running,
            connection_state: ref.connection_state || e.connection_state || null,
            version: ref.version || e.version,
            version_date: ref.version_date || e.version_date,
          };
        });
    }
    function nodeCellHtml(n, procIndex, procTotal) {
      const href = "/proxy/" + encodeURIComponent(n.name) + "/dms-system.html";
      const suffix = (typeof procIndex === "number" && typeof procTotal === "number" && procTotal > 0)
        ? " (" + (procIndex + 1) + "/" + procTotal + ")" : "";

      return `
        <a class="node" href="${href}">${n.alias || n.name}</a><br>
        <span class="muted">${n.host}:${n.port}${suffix}</span>
      `;
    }
    function applyOverlays(data) {
      const extra = (data && data.extra) || {};
      const verMap = extra.versions || {};
      const presdVer = extra.presd_versions || {};
      const aicVer = extra.aic_versions || {};                     // ‚òÖ Ï∂îÍ∞Ä
      const conn = extra.connected_daemons || {};
      const presdIps = Array.isArray(extra.presd_ips)              // ‚òÖ Î∞∞Ïó¥ Î≥¥Ïû•
        ? extra.presd_ips
        : [];
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];

      const ipFromHost = (s) => {
        const m = String(s || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s || "");
      };
      const listFromStatus = (status) => {
        if (!status) return [];
        if (status.data && typeof status.data === "object") return Object.values(status.data);
        if (Array.isArray(status.processes)) return status.processes;
        if (Array.isArray(status.executables)) return status.executables;
        return [];
      };

      for (const n of nodes) {
        const nodeIp = ipFromHost(n.host);
        const procs = listFromStatus(n.status);
        for (const p of procs) {
          if (!p || !p.name) continue;

          // ‚îÄ‚îÄ AIc Î≤ÑÏ†Ñ Ïò§Î≤ÑÎ†àÏù¥ (ip / process Í∏∞Î∞ò)
          if (p.name === "AIc" && aicVer) {
            const alias = (p.alias || "").trim();
            let src = null;

            // aic_versions Íµ¨Ï°∞: { "<ip>": { "<proc_or_alias>": {version,date}, ... }, ... }
            for (const [ip, byName] of Object.entries(aicVer)) {
              if (!byName || typeof byName !== "object") continue;
              if (alias && alias in byName) {
                src = byName[alias];
                break;
              }
            }

            // alias Î°ú Î™ª Ï∞æÏïòÏúºÎ©¥, ÎÖ∏Îìú IP + "AIc" Ïù¥Î¶ÑÏúºÎ°ú Ìïú Î≤à Îçî ÏãúÎèÑ
            if (!src) {
              const byName = aicVer[nodeIp];
              if (byName && typeof byName === "object" && byName["AIc"]) {
                src = byName["AIc"];
              }
            }

            if (src) {
              p.version = src.version || "-";
              p.version_date = src.date || "-";
            }
          }

          // ‚îÄ‚îÄ PreSd Î≤ÑÏ†Ñ Ïò§Î≤ÑÎ†àÏù¥
          if (p.name === "PreSd") {
            const src =
              presdVer[nodeIp] ||
              (verMap.PreSd && (verMap.PreSd[nodeIp] || (verMap.PreSd.byIp && verMap.PreSd.byIp[nodeIp]))) ||
              null;
            if (src) {
              p.version = src.version || "-";
              p.version_date = src.date || "-";
            } else if (verMap.PreSd && verMap.PreSd.version) {
              p.version = verMap.PreSd.version || "-";
              p.version_date = verMap.PreSd.date || "-";
            }
          } else if (verMap[p.name]) {
            p.version = verMap[p.name].version || p.version || "-";
            p.version_date = verMap[p.name].date || p.version_date || "-";
          }

          // ‚îÄ‚îÄ CONNECTED Ïò§Î≤ÑÎ†àÏù¥ (Î©ÄÌã∞ Ïù∏Ïä§ÌÑ¥Ïä§ ÏßÄÏõê)
          if (conn) {
            // PreSd: Í∏∞Ï°¥ Î∞©Ïãù Ï†úÍ±∞ÌïòÍ≥† AIc Î∞©ÏãùÍ≥º ÎèôÏùºÌïòÍ≤å Ï≤òÎ¶¨
            if (p.name === "PreSd") {
                const psConn = conn.PreSd;

                // PreSd: ["10.82.104.210", "10.82.104.211"] ÌòïÌÉú
                if (Array.isArray(psConn)) {
                    if (psConn.includes(nodeIp)) {
                        p.connection_state = "CONNECTED";
                    }
                }
                // ÌòπÏãú dictionary ÌòïÌÉú Î∞©Ïñ¥
                else if (psConn && typeof psConn === "object") {
                    if (psConn[nodeIp] === true) {
                        p.connection_state = "CONNECTED";
                    }
                }
            }

            // AIc: Î©ÄÌã∞ Ïù∏Ïä§ÌÑ¥Ïä§ Í∞úÎ≥Ñ IP Í∏∞Î∞ò CONNECTED ÌåêÏ†ï
            else if (p.name === "AIc") {
              const aiConn = conn.AIc;

              // conn.AIc Í∞Ä ["ip1","ip2"] ÌòïÌÉúÎ©¥
              if (Array.isArray(aiConn)) {
                  if (aiConn.includes(nodeIp)) {
                      p.connection_state = "CONNECTED";
                  }
              }
              // Í∏∞Ï°¥ dictionary ÌòïÌÉúÎèÑ Ïú†ÏßÄ (ÌòπÏãúÎùºÎèÑ)
              else if (aiConn && typeof aiConn === "object") {
                  if (aiConn[nodeIp] === true) {
                      p.connection_state = "CONNECTED";
                  }
              }
            }
            else {
                const entry = conn[p.name];

                // Case 1: boolean true ‚Üí Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ
                if (entry === true) {
                    p.connection_state = "CONNECTED";
                }
                // Case 2: ["10.82.104.210"] Ïù¥Îü∞ Î¶¨Ïä§Ìä∏Î©¥ nodeIp Í≤ÄÏÇ¨
                else if (Array.isArray(entry)) {
                    if (entry.includes(nodeIp)) {
                        p.connection_state = "CONNECTED";
                    }
                }             
            }
          }
        }
      }

      // alias_map Ï†ÑÎã¨
      OMS_ALIAS_MAP = extra.alias_map || {};
    }
    function effectiveStateOf(procObj) {
      if (!procObj) return "STOPPED";
      const running = !!procObj.running;
      const conn = String(procObj.connection_state || "").toUpperCase();
      if (!running) return "STOPPED";
      if (conn === "CONNECTED") return "CONNECTED";
      return "RUNNING";
    }
    function render(data) {
      if (!data) return;
      applyOverlays(data);
      lastData = data;
      
      const hbSecRaw = Number(data && data.heartbeat_interval_sec);
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];
      const summary = (data && data.summary) || {};

      if (!Number.isNaN(hbSecRaw) && hbSecRaw > 0) {
        const nextMs = Math.max(800, Math.min(10000, Math.floor(hbSecRaw * 1000)));
        if (nextMs !== POLL_MS) startPolling(nextMs);
        HB.textContent = "poll " + hbSecRaw + "s";
      } else {
        HB.textContent = "poll -";
      }

      TBody.innerHTML = "";
      if (nodes.length === 0) {
        const nodesCount      = summary.nodes      ?? 0;
        const processesCount  = summary.processes  ?? 0;
        const connectedCount  = summary.connected  ?? 0;
        const runningCount    = summary.running    ?? 0;
        const stoppedCount    = summary.stopped    ?? 0;
        META.textContent =
          `nodes: ${nodesCount} ‚Ä¢ processes: ${processesCount}` +
          ` ( connected: ${connectedCount} / running: ${runningCount} / stopped: ${stoppedCount} )`;
        TBody.innerHTML = '<tr class="other"><td colspan="5" class="muted">no nodes</td></tr>';
        return;
      }

      const VERS = (data && data.extra && data.extra.versions) || {};
      const PRESD_VERS = (data && data.extra && data.extra.presd_versions) || {};
      const ipOf = (s) => {
        const m = String(s || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s || "");
      };

      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        let shown = selectedProcList(n.status);
        
        if (!n.status) {
          TBody.insertAdjacentHTML("beforeend",
            '<tr class="other"><td>' + nodeCellHtml(n, 0, 0) + '</td><td colspan="4" class="muted">unreachable</td></tr>');
          continue;
        }

        if (shown.length === 0) {
          const fallback = toProcList(n.status).map(x => ({
            name: (x && (x.name || x.proc || x.id)) || "-",
            alias: (x && x.alias) || "",
            running: !!(x && (x.running || String(x.status || "").toLowerCase() === "running")),
            connection_state: (x && x.connection_state) || null,
            select: true
          }));
          if (fallback.length > 0) {
            shown = fallback;
          } else {
            TBody.insertAdjacentHTML("beforeend",
              '<tr class="other"><td>' + nodeCellHtml(n, 0, 0) + '</td><td colspan="4" class="muted">no processes</td></tr>');
            continue;
          }
        }

        for (let j = 0; j < shown.length; j++) {
          const p = shown[j];
          const nodeIp = ipOf(n.host);

          const _rv = (proc, ip) => {
            if (p && typeof p.version === "string" && p.version.trim()) return p.version;
            if (proc === "PreSd") {
              return (PRESD_VERS[ip]?.version)
                || (VERS.PreSd?.[ip]?.version)
                || (VERS.PreSd?.byIp?.[ip]?.version)
                || (VERS.PreSd?.version)
                || "-";
            }
            return (VERS[proc]?.version) || "-";
          };

          const eff = effectiveStateOf(p);
          const badge =
            eff === "STOPPED" ? '<span class="pill bad">STOPPED</span>' :
            eff === "CONNECTED" ? '<span class="pill connected">CONNECTED</span>' :
            '<span class="pill ok">RUNNING</span>';

          const rowCls = (eff === "STOPPED") ? "stopped" : "running";
          const verText = _rv(p.name, nodeIp);
          const dateText = (p && typeof p.version_date === "string" && p.version_date.trim())
            ? p.version_date
            : (p.name === "PreSd"
              ? (PRESD_VERS[nodeIp]?.date
                || VERS.PreSd?.[nodeIp]?.date
                || VERS.PreSd?.byIp?.[nodeIp]?.date
                || VERS.PreSd?.date
                || "-")
              : (VERS[p.name]?.date || "-"));
          const verHtml = verText + '<br><span class="muted">' + (dateText || "-") + "</span>";

          const dmsAlias = (p.alias || "").trim();
          const omsAlias = (OMS_ALIAS_MAP[p.name] || "").trim();
          let aliasHtml = "";
          if (dmsAlias && omsAlias && dmsAlias !== omsAlias) {
            aliasHtml = '<br><span class="muted" title="OMS alias: ' + omsAlias + '">' + dmsAlias + "</span>";
          } else {
            const a = dmsAlias || omsAlias;
            aliasHtml = a ? '<br><span class="muted">' + a + "</span>" : "";
          }

          TBody.insertAdjacentHTML("beforeend",
            '<tr class="' + rowCls + '">' +
              '<td>' + nodeCellHtml(n, j, shown.length) + "</td>" +
              '<td>' + (p.name || "-") + aliasHtml + "</td>" +
              '<td>' + verHtml + "</td>" +
              '<td>' + badge + "</td>" +
              '<td><button class="btn-secondary" data-a="logs" data-node="' +
                n.name + '" data-proc="' + p.name + '">üìú Logs</button></td>' +
            "</tr>");
        }
      }

      const bullet = "\u2022";
      // ‚úÖ summary Í∏∞Ï§ÄÏúºÎ°ú Î©îÌÉÄ/Ïù¥Î≤§Ìä∏ Î∞òÏòÅ (ÏóÜÏúºÎ©¥ ÏµúÏÜå fallback)
      const nodesCount      = summary.nodes      ?? nodes.length;
      const processesCount  = summary.processes  ?? 0;
      const connectedCount  = summary.connected  ?? 0;
      const runningCount    = summary.running    ?? 0;
      const stoppedCount    = summary.stopped    ?? 0;

      META.textContent =
        `nodes: ${nodesCount} ‚Ä¢ processes: ${processesCount} ( connected: ${connectedCount} / running: ${runningCount} / stopped: ${stoppedCount} )`;

      const OSM_SUMMARY = {
        // Í∑∏ÎåÄÎ°ú summaryÎ•º ÌùòÎ†§Î≥¥ÎÇ¥Îêò, ÌïÑÏàòÍ∞í ÏóÜÏúºÎ©¥ ÏµúÏÜåÌïúÏùò fallback
        nodes: nodesCount,
        processes: processesCount,
        connected: connectedCount,
        running: runningCount,
        stopped: stoppedCount,
        ts: Date.now(),
        source: "oms-system"
      };
      try {
        window.OMS = window.OMS || {};
        window.OMS.summary = OSM_SUMMARY;
        window.dispatchEvent(new CustomEvent("oms:summary", { detail: OSM_SUMMARY }));
      } catch (e) {
        if (DEBUG) console.warn("oms:summary dispatch failed", e);
      }
    }

    async function reloadNow(opts = {}) {
      const silent = !!opts.silent;
      try {
        if (!silent) setBusy(true);
        clearErr();
        const data = await api("/oms/system/state");
        render(data);

        // state/message chip ÏóÖÎç∞Ïù¥Ìä∏ (Í≥µÌÜµ Ìï®Ïàò Ìò∏Ï∂ú)
        applyStateAndMessage({
          state: data.state,
          message: data.message,
          stateEl: STATE,
          messageEl: MESSAGE
        });

      } catch (e) {
        showErr(e.message || String(e));
      } finally {
        if (!silent) setBusy(false);
      }
    }
    document.querySelector("#grid tbody").addEventListener("click", ev => {
      const b = ev.target.closest("button"); if (!b) return;
      if (b.dataset.a === "logs") {
        const url = "/web/log-viewer.html?node=" +
          encodeURIComponent(b.dataset.node) +
          "&name=" + encodeURIComponent(b.dataset.proc);
        window.open(url, "_blank");
      }
    });

    // ========================================================================
    // Button Action
    // ========================================================================
    
    // ‚îÄ [Button] Reload ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    
    BTN_SYS_LOGS.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      // OMS Î°úÍ∑∏Îäî daemon/OMs/log Ïóê ÏûàÏùå ‚Üí name=OMs
      const url = base + "/web/log-viewer.html?name=OMs&tail=50000";
      window.open(url, "_blank");
    };
    // ‚îÄ [Button] Reload ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_SYS_RELOAD.onclick = () => reloadNow({ silent: false });
    // ‚îÄ [Button] Restart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_SYS_RESTART.onclick = async () => {
      await (window.__OMS_ACTIONS_LOAD__ || Promise.resolve());
      clearProgressChip();

      const Actions = window.OMS?.Actions;
      if (!Actions?.sysRestart) {
          alert("System Restart-All not available");
          return;
      } 
      try {
        await Actions.sysRestart();
      } catch (e) {
        alert("System Restart-All failed: " + (e?.message || e));
      }
    };
    // ‚îÄ [Button] Connect ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_SYS_CONNECT.onclick = async () => {
      // ‚úÖ Connect ÏãúÏûë ÏãúÏóêÎèÑ ÏßÄÎÇú Î©îÏãúÏßÄ clear
      await (window.__OMS_ACTIONS_LOAD__ || Promise.resolve());
      clearProgressChip();      

      try {
        const Actions = window.OMS?.Actions;
        if (!Actions?.sysConnect) {
            alert("System Connect not available");
            return;
        } 
        try {
          await Actions.sysConnect();
        } catch (e) {
          alert("System Connect failed: " + (e?.message || e));
        }
        await reloadNow({ silent: false });
      } catch (e) {
        console.error("sysConnect failed", e);
        await reloadNow({ silent: false }).catch(()=>{});
      }    
    };
    // ‚îÄ [Button] Dashboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_DASHBOARD.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      window.location.href = base + "/dashboard";
    };
    // ‚îÄ [Button] Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_CONFIG.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      window.location.href = base + "/web/oms-config.html";
    };

    // ÌéòÏù¥ÏßÄÍ∞Ä Ï§ÄÎπÑÎêòÎ©¥ actions Î†àÏù¥Ïñ¥Ïóê hookÍ≥º uiÎ•º ÎÑòÍ≤®Ï§ÄÎã§
    function mountActionsOnce() {
      if (!(window.OMS && window.OMS.Actions)) return;
      try {
        window.OMS.Actions.mountPage({
          hooks: {
            reloadNow: (opts) => reloadNow(opts),
            render: (data) => render(data)
          }
        });
        if (window.OMS.__ui && typeof window.OMS.Actions.setUi === "function") {
          window.OMS.Actions.setUi(window.OMS.__ui);
        }
      } catch (e) {
        console.error("mountPage failed", e);
      }
    }
    // Ï¥àÍ∏∞ Î∂ÄÌåÖ: Ìïú Î≤àÎßå Î™ÖÏãúÏ†ÅÏúºÎ°ú Ìò∏Ï∂ú
    (function bootstrap() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          reloadNow({ silent: false }).catch(e => console.error(e));
          startPolling(POLL_MS);
        });
      } else {
        reloadNow({ silent: false }).catch(e => console.error(e));
        startPolling(POLL_MS);
      }

      // Summary Ïù¥Î≤§Ìä∏Î°ú Title ÏòÜ metaÎèÑ Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
      window.addEventListener("oms:summary", (ev) => {
          const d = ev.detail || {};
          const bullet = "\u2022";
          META.textContent =
            "nodes: " + (d.nodes || 0) + " " + bullet +
            " processes: " + (d.processes || 0) +
            " ( connected: " + (d.connected || 0) +
            " / running: " + (d.running || 0) +
            " / stopped: " + (d.stopped || 0) + " )";
      });

    })();

    // ‚îÄ Restart Lock 
    (function syncRestartLock() {
      function applyLock(locked) {
        const on = !!locked;
        if (BTN_SYS_RESTART) BTN_SYS_RESTART.disabled = on;
        if (BTN_SYS_CONNECT) BTN_SYS_CONNECT.disabled = on;
      }

      // ÌéòÏù¥ÏßÄ ÏßÑÏûÖ Ïãú ÌòÑÏû¨ lock ÏÉÅÌÉú Ìïú Î≤à Î∞òÏòÅ
      try {
        if (window.OMS && window.OMS.Actions && typeof window.OMS.Actions.isSysRestartLocked === "function") {
          applyLock(window.OMS.Actions.isSysRestartLocked());
        }
      } catch { }

      // BroadcastChannel Î°ú Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî
      try {
        const bc = new BroadcastChannel("oms-restart-lock");
        bc.onmessage = (e) => {
          if (!e || !e.data) return;
          applyLock(!!e.data.locked);
        };
      } catch { }
    })();
  </script>
</body>
</html>
