<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>4DReplay V5 - OMs System</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <link rel="icon" href="images/4dmain.ico" type="image/x-icon">
  <style>
    :root{
      --bg:#0b0f14; --fg:#eef2f7; --muted:#94a3b8;
      --th:#0f172a; --line:#243045; --line2:#1f2937;
      --row-run:#0e2416; --row-stop:#171a1e;
      --badge-ok:#1f9d48; --badge-bad:#b83a3a;
      --btn:#1e40af; --btn2:#334155; --ok:#16a34a; --bad:#ef4444; --warn:#f59e0b;
    }
    html,body{height:100%}
    body{background:var(--bg);color:var(--fg);font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,
      "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Noto Emoji",sans-serif;margin:24px}
    h2{font-size:32px;margin:0 0 14px;display:flex;align-items:center;gap:8px}
    h2 small{font-size:14px;color:var(--muted)}
    .toolbar{display:flex;gap:10px;margin:8px 0 16px;align-items:center;flex-wrap:wrap}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid var(--line);padding:10px}
    th{background:var(--th);text-align:left}
    tr.running td{ background:var(--row-run); }
    tr.other   td{ background:var(--row-stop); }
    .pill{
      font-family: inherit;
      display:inline-block;padding:6px 12px;border-radius:999px;border:1px solid;
      line-height:1;font-weight:500;letter-spacing:.3px;background:transparent
    }
    .badge-ok { color:#22c55e;border-color:var(--badge-ok); }
    .badge-bad{ color:#f87171;border-color:var(--badge-bad); }
    /* NEW: CONNECTED ëŠ” í° ê¸€ì + ì•½ê°„ ë‘ê»ê²Œ */
    .badge-connected { color:#fff !important; font-weight:600; border-color:var(--badge-ok); }
    /* NEW: RUNNING ì€ ê¸°ì¡´ ì´ˆë¡ í†¤ ìœ ì§€(ê°€ë…ì„± ìœ„í•´ í´ë˜ìŠ¤ë§Œ ë¶„ë¦¬) */
    .badge-running   { color:#22c55e; border-color:var(--badge-ok); }
    .pill-ok{ color:#22c55e;border-color:var(--ok); }
    .pill-bad{ color:#f87171;border-color:var(--bad); }
    .pill-warn{ color:#fbbf24;border-color:var(--warn); }
    .muted{color:var(--muted)}
    button{
      font-family: inherit;
      background:var(--btn);color:#fff;border:0;border-radius:14px;
      padding:8px 14px;cursor:pointer;display:inline-flex;align-items:center;gap:6px;
      transition:filter .2s ease
    }
    .btn-secondary{ background:var(--btn2); }
    button:hover{ filter:brightness(1.08) }
    .toolbar button{ border-radius:12px; padding:10px 16px }
    a.node{color:#93c5fd;text-decoration:none}
    a.node:hover{text-decoration:underline}
    .spacer{flex:1}
    .chip{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);background:#0f172a;border-radius:12px;padding:6px 10px;color:var(--fg)}
    #progressChip{
      min-width: 180px;
      justify-content: center;
      white-space: nowrap;
      flex: 0 0 auto;
      visibility: hidden;
    }
    #busyMsg{margin-left:8px;opacity:.9}
    #err{display:none;margin:8px 0;padding:10px;border-radius:8px;background:#3b0d0d;border:1px solid #ef4444;color:#ffe0e0;white-space:pre-wrap}

    .panel{margin-top:18px;border:1px solid var(--line2);border-radius:12px;padding:12px;background:#0b1220}
    .kv{display:grid;grid-template-columns:150px 1fr;gap:8px;align-items:center}
    textarea{width:100%;height:180px;resize:vertical;background:#0b1220;color:#e5e7eb;border:1px solid var(--line);border-radius:8px;padding:8px;font:13px ui-monospace,monospace;}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b1220;border:1px solid var(--line);border-radius:8px;padding:10px;max-height:280px;overflow:auto}
    .btn-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  </style>
</head>
<body>
  <h2>
    <span>4DReplay V5 - OMs System</span>
    <small id="meta"></small>
  </h2>

  <div class="toolbar">
    <button id="btnConfig" class="btn-secondary">ğŸ“ Config Editor</button>
    <button id="btnReload" class="btn-secondary">ğŸ”„ Reload</button>
    <button id="omsRestartAll" class="btn-secondary">âŸ³ Restart All</button>
    <span id="progressChip" class="chip" role="status" aria-live="polite"></span>
    <span class="spacer"></span>
    <span class="chip" id="hb">poll -</span>
  </div>

  <div id="err"></div>

  <table id="grid">
    <thead>
      <tr>
        <th>Node</th>
        <th>Process</th>
        <th>Version</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <p class="muted" style="margin-top:10px">
    Tip: Logs are reachable via OMS proxy (<code>/proxy/&lt;node&gt;/â€¦</code>).
  </p>

  <div class="panel">
    <h3 style="margin:0 0 8px">Connect Sequence (one-by-one via /oms/mtd-connect)</h3>
    <div class="kv">
      <span>MTd Host</span>
      <input id="seqHost" type="text" placeholder="10.82.x.x or hostname">
      <span>MTd Port</span>
      <input id="seqPort" type="number" min="1" max="65535" value="19765">
      <span>DMPDIP</span>
      <input id="seqMgmtIP" type="text" placeholder="127.0.0.1">
    </div>

    <div class="btn-row" style="margin:8px 0">
      <label class="chip"><input type="checkbox" id="seqAutoToken" checked> Auto Token</label>
      <label class="chip"><input type="checkbox" id="seqSanitize" checked> Sanitize DaemonList</label>
      <label class="chip"><input type="checkbox" id="seqDryRun"> Dry-Run</label>
      <label class="chip"><input type="checkbox" id="seqVerbose"> Verbose Trace</label>
      <button id="btnSeqFillFromList" class="btn-secondary">ğŸ§© Fill from List</button>
      <span class="spacer"></span>
      <span id="seqStatus" class="pill">Idle</span>
    </div>

    <div class="kv">
      <span>Daemon Map (JSON)</span>
      <textarea id="seqDaemonMap" spellcheck="false" placeholder='{
  "EMd": "10.82.104.210",
  "CCd": "10.82.104.210",
  "SCd": "10.82.104.210",
  "GCd": "10.82.104.210",
  "PCd": "10.82.104.210",
  "SPd": "10.82.104.213",
  "AId": "10.82.104.215"
}'></textarea>
    </div>

    <div class="btn-row" style="margin-top:8px">
      <button id="btnSeqStart">ğŸš€ Run Sequence</button>
      <button id="btnSeqAbort" class="btn-secondary">â›” Abort</button>
      <span class="spacer"></span>
      <button id="btnCopySeqLog" class="btn-secondary">ğŸ“‹ Copy Log</button>
      <button id="btnSaveSeqLog" class="btn-secondary">ğŸ’¾ Save Log</button>
    </div>

    <h4 style="margin:12px 0 6px">Progress</h4>
    <pre id="seqLog">-</pre>
  </div>

  <script>
    const DEBUG=false;
    const TBody=document.querySelector("#grid tbody");
    const HB=document.getElementById("hb");
    const META=document.getElementById("meta");
    const PROG=document.getElementById("progressChip");
    const ERR=document.getElementById("err");
    const BTN_RELOAD=document.getElementById("btnReload");
    const BTN_CONFIG=document.getElementById("btnConfig");
    const BTN_RA=document.getElementById("omsRestartAll");

    // --- Connect Sequence refs
    const SEQ = {
      host: document.getElementById("seqHost"),
      port: document.getElementById("seqPort"),
      mgmt: document.getElementById("seqMgmtIP"),
      autoToken: document.getElementById("seqAutoToken"),
      sanitize: document.getElementById("seqSanitize"),
      dryRun: document.getElementById("seqDryRun"),
      mapArea: document.getElementById("seqDaemonMap"),
      status: document.getElementById("seqStatus"),
      log: document.getElementById("seqLog"),
      btnFill: document.getElementById("btnSeqFillFromList"),
      btnStart: document.getElementById("btnSeqStart"),
      btnAbort: document.getElementById("btnSeqAbort"),
      btnCopy: document.getElementById("btnCopySeqLog"),
      btnSave: document.getElementById("btnSaveSeqLog"),
      verbose:  document.getElementById("seqVerbose"),
    };
    let SEQ_ABORT=false;

    let lastData=null;
    let OMS_ALIAS_MAP = {};
    let POLLER = null;
    let RA_LOCK = false;
    let POLL_MS = 3000;
    let RA_FINAL = false;          // ì™„ë£Œ/ì—ëŸ¬/idle ì´í›„ true â†’ ë” ì´ìƒ ë®ì§€ ì•ŠìŒ
    let RA_MSG_PRIORITY = 0;       // í˜„ì¬ ë©”ì‹œì§€ ìš°ì„ ìˆœìœ„ (ë†’ì„ìˆ˜ë¡ ê°•í•¨)
    let RA_SEEN_RUNNING = false;   // running ì„ í•œ ë²ˆì´ë¼ë„ ë³¸ í›„ì—ë§Œ ì™„ë£Œ ì¸ì •
    let RA_SESSION_ID = 0;         // ì¬ì‹œì‘ ì„¸ì…˜ ê°€ë“œ
    const RA_IDLE_GRACE_MS = 3000; // í´ë¦­ í›„ ì´ˆê¸° idle ë¬´ì‹œ ìœ ì˜ˆ
    
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Proxy-safe API prefix (works with /proxy/<node>/â€¦) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const __PROXY_PREFIX__ = (() => {
      const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
      return m ? `/proxy/${encodeURIComponent(decodeURIComponent(m[1]))}` : "";
    })();
    const API = __PROXY_PREFIX__ || ""; // same-origin under proxy or root

    function startPolling(ms){
      if (typeof ms === "number" && isFinite(ms) && ms > 0) {
        POLL_MS = ms;
      }
      stopPolling();
      POLLER = setInterval(()=>{ if(!RA_LOCK) reloadNow().catch(()=>{}); }, POLL_MS);
      if (DEBUG) console.debug("[OMS] poll started:", POLL_MS, "ms");
    }
    function stopPolling(){
      if (POLLER){ clearInterval(POLLER); POLLER=null; }
    }

    // â”€â”€ ì§„í–‰ì¹© ì¹´ìš´íŒ… ìœ í‹¸: ì„ íƒëœ í”„ë¡œì„¸ìŠ¤ ì¤‘ running/stop ìˆ˜ ê³„ì‚°
    function computeProgressFromStatus(data){
      const nodes = Array.isArray(data && data.nodes) ? data.nodes : [];
      let total=0, run=0, stop=0;
      for (const n of nodes){
        const procs = selectedProcList(n.status);
        for (const p of procs){
          total += 1;
          if (p.running === true) run += 1; else stop += 1;
        }
      }
      return { total, run, stop };
    }

    // â”€â”€ Restart-All ì¤‘ ì§„í–‰ì¹©ë§Œ ê°±ì‹ í•˜ëŠ” ê²½ëŸ‰ í´ëŸ¬
    let RA_PROGRESS_POLLER = null;
    async function startRaProgressPolling(){
      stopRaProgressPolling();
      RA_PROGRESS_POLLER = setInterval(async ()=>{
        try{
          const st = await api("/oms/status");
          const { total, run, stop } = computeProgressFromStatus(st);
          const s = await api("/oms/restart/state").catch(()=>null);
          const base = (s && s.message) ? s.message : "Restartingâ€¦";
          raWrite(`${base} (${run}/${total} running Â· ${stop}/${total} stopped)`, 1);
        }catch(_){}
      }, 800);
    }
    function stopRaProgressPolling(){
      if (RA_PROGRESS_POLLER){ clearInterval(RA_PROGRESS_POLLER); RA_PROGRESS_POLLER=null; }
    }
    async function api(path, init={}) {
      // restart/state ê°±ì‹ ì´ ë©ˆì¶”ëŠ” ê±¸ ë°©ì§€í•˜ê¸° ìœ„í•´ proxy-safe í”„ë¦¬í”½ìŠ¤ ì ìš©
      const url = (typeof path === "string" && path.startsWith("/")) ? (API + path) : path;
      const res = await fetch(url, { cache:"no-store", ...init });
      const ct = res.headers.get("content-type") || "";
      const isJson = ct.includes("application/json");
      const body = isJson ? await res.json().catch(()=>({})) : await res.text().catch(()=> "");
      if (!res.ok) throw new Error(isJson ? (body.error||`HTTP ${res.status}`) : (body||`HTTP ${res.status}`));
      return body;
    }
    function showErr(m){ ERR.style.display="block"; ERR.textContent=m; }
    function clearErr(){ ERR.style.display="none"; ERR.textContent=""; }
    function setBusy(on){
      BTN_RELOAD.disabled = on || RA_LOCK;
      BTN_CONFIG.disabled  = on || RA_LOCK;
      BTN_RA.disabled      = on || RA_LOCK;
    }

    // ===== Connect Sequence helpers =====
    function seqSetStatus(text, kind="pill-warn"){
      if (!SEQ.status) return;
      SEQ.status.className = `pill ${kind}`;
      SEQ.status.textContent = text;
    }
    function appendLog(line, obj){
      if (!SEQ.log) return;
      const ts = new Date().toLocaleTimeString();
      let headStr;
      // 1) ì²« ì¸ìê°€ ê°ì²´/ë°°ì—´ì´ë©´ JSONìœ¼ë¡œ ë³€í™˜
      if (typeof line === "object" && line !== null){
        try { headStr = JSON.stringify(line, null, 2); }
        catch { headStr = String(line); }
        obj = undefined; // ë‘ ë²ˆì§¸ ì¤„ì€ ë³„ë„ ì¶œë ¥ ì•ˆ í•¨
      } else {
        headStr = String(line);
      }
      // 2) ë‘ ë²ˆì§¸ ì¸ìê°€ ê°ì²´/ë°°ì—´ì´ë©´ JSONìœ¼ë¡œ ë³€í™˜
      let tailStr = "";
      if (obj !== undefined){
        try { tailStr = `\n${JSON.stringify(obj, null, 2)}`; }
        catch { tailStr = `\n${String(obj)}`; }
      }
      // 3) ê³¼ë„í•œ ì¶œë ¥ ë³´í˜¸(200KB ì´ìƒì€ ì˜ë¼ëƒ„)
      const cap = (txt)=> (txt.length > 200_000 ? txt.slice(0, 200_000) + "\n...[truncated]..." : txt);
      let s = `[${ts}] ${cap(headStr)}${cap(tailStr)}`;
      if (SEQ.log.textContent === "-" || !SEQ.log.textContent) {
        SEQ.log.textContent = s;
      } else {
        SEQ.log.textContent += `\n${s}`;
      }
      SEQ.log.scrollTop = SEQ.log.scrollHeight;
    }
    function parseDaemonMap(){
      const txt = (SEQ.mapArea?.value||"").trim();
      if (!txt) return {};
      try { return JSON.parse(txt); } catch(e) {
        throw new Error("Daemon Map JSON parse error: " + e.message);
      }
    }
    function sanitizeDaemonMap(dm){
      // SPd/MMd ë™ì¹˜ ì²˜ë¦¬ + ë¹ˆ ê°’ ì œê±°
      const out = {};
      for (const [k,v] of Object.entries(dm||{})){
        if (!v) continue;
        out[k] = v;
      }
      return out;
    }

    const PROG_LS_KEY = "oms_ra_progress";
    /**
     * ì§„í–‰ì¹© ë©”ì‹œì§€ ì“°ê¸° (ìš°ì„ ìˆœìœ„ ê¸°ë°˜)
     * @param {string} text
     * @param {number} priority 1=progress, 2=live, 3=SSE, 10=final
     */
    function raWrite(text, priority=1){
      if (RA_FINAL && priority < 10) return;            // ì™„ë£Œ ì´í›„ì—” finalë§Œ í—ˆìš©
      if (priority < RA_MSG_PRIORITY) return;           // ë‚®ì€ ìš°ì„ ìˆœìœ„ëŠ” ë¬´ì‹œ
      RA_MSG_PRIORITY = priority;
      PROG.style.visibility = "visible";
      const msg = (text && String(text).trim()) ? text : (PROG.textContent.trim() || "Workingâ€¦");
      if (PROG.textContent !== msg) PROG.textContent = msg;
      try { localStorage.setItem(PROG_LS_KEY, msg); } catch {}
    }
    function raClear(){
      // ì‹œì‘ ì‹œ ì´ˆê¸°í™” (ì™„ë£Œ ë©”ì‹œì§€ëŠ” ìœ ì§€)
      RA_FINAL = false;
      RA_MSG_PRIORITY = 0;
      RA_SEEN_RUNNING = false;
    }
    new MutationObserver(()=>{
      // ì™„ë£Œ ì ê¸ˆ ì‹œ ì™¸ë¶€ ë³µêµ¬ ì‹œë„ ë¬´ì‹œ
      if (RA_FINAL) return;
      if (!PROG.textContent || !PROG.textContent.trim()){
        const cached = localStorage.getItem(PROG_LS_KEY);
        if (cached && cached.trim()) PROG.textContent = cached;
        else PROG.textContent = "Workingâ€¦";
      }
    }).observe(PROG, {characterData:true, childList:true, subtree:true});
    window.addEventListener("storage", (e)=>{
      // ì™„ë£Œ ì ê¸ˆ ì‹œ ì™¸ë¶€ íƒ­ ê°±ì‹  ë¬´ì‹œ
      if (RA_FINAL) return;
      if (e.key === PROG_LS_KEY && typeof e.newValue === "string"){
        PROG.style.visibility = "visible";
        if (e.newValue.trim()) PROG.textContent = e.newValue;
      }
    });
    (function(){ const cached = localStorage.getItem(PROG_LS_KEY); if (cached) { PROG.style.visibility="visible"; PROG.textContent=cached; }})();

    function toProcList(status){
      if (!status) return [];
      if (status.data && typeof status.data==="object") return Object.values(status.data);
      if (Array.isArray(status.processes)) return status.processes;
      if (Array.isArray(status.executables)) return status.executables;
      return [];
    }
    
    // dms-systemê³¼ ë™ì¼ ê·œì¹™: "executables"ì˜ select=trueê°€ í‘œ ëŒ€ìƒ,
    // runningì€ processes.running(ì—†ìœ¼ë©´ executables.status ë¬¸ìì—´)ë¡œ íŒë‹¨
    // ì„ íƒëœ(executables.select=true) í”„ë¡œì„¸ìŠ¤ë§Œ í‘œì‹œí•˜ë˜,
    // ì‹¤í–‰/ì—°ê²° ìƒíƒœëŠ” processes/executables/data ë¥¼ ëª¨ë‘ ë³‘í•©í•´ì„œ íŒë‹¨
    function selectedProcList(status){
      if (!status) return [];
      const execs = Array.isArray(status.executables) ? status.executables : [];
      const procs = Array.isArray(status.processes) ? status.processes : [];
      const dataObjs = (status.data && typeof status.data === "object") ? Object.values(status.data) : [];

      // ìƒíƒœ ë³‘í•© ë§µ êµ¬ì„± (name ë‹¨ìœ„ë¡œ ê°€ì¥ í’ë¶€í•œ í•„ë“œê°€ ë‚¨ë„ë¡ ë®ì–´ì“°ê¸°)
      const stateMap = Object.create(null);
      const ingest = (arr)=> {
        for (const x of (arr||[])){
          if (!x || !x.name) continue;
          stateMap[x.name] = { ...(stateMap[x.name]||{}), ...x };
        }
      };
      ingest(procs);      // ë³´í†µ ì—¬ê¸°ì— running(boolean)ì´ ìˆìŒ
      ingest(execs);      // ì¼ë¶€ ë°°í¬ì—ì„  status ë¬¸ìì—´ì´ ì—¬ê¸° ì¡´ì¬
      ingest(dataObjs);   // êµ¬ë²„ì „/ì»¤ìŠ¤í…€ ë°°í¬ì—ì„œ ì—¬ê¸°ì— ìƒíƒœê°€ ì„ì—¬ ìˆìŒ

      const normRunning = (v)=>{
        if (typeof v === "boolean") return v;
        const s = String(v||"").trim().toLowerCase();
        // ë‹¤ì–‘í•œ í‘œí˜„ ëŒ€ì‘
        return s === "running" || s === "started" || s === "ok" || s === "online";
      };

      // executables ì¤‘ ì„ íƒëœ ê²ƒë§Œ, ë³‘í•©ëœ ìƒíƒœë¡œ ë°˜í™˜
      return execs
        .filter(e => e && e.select === true)
        .map(e => {
          const ref = stateMap[e.name] || {};
          const running = normRunning(
            ref.running ?? ref.status ?? e.running ?? e.status
          );
          return {
            name: e.name,
            alias: e.alias || ref.alias || "",
            select: true,
            running,
            connection_state: ref.connection_state || e.connection_state || null,
            // ë²„ì „/ë‚ ì§œê°€ ë‹¤ë¥¸ ê³³ì— ìˆë‹¤ë©´ ì´í›„ applyOverlaysì—ì„œ ë®ì„
          };
        });
    }
    // ë…¸ë“œ ì…€: í”„ë¡œì„¸ìŠ¤ ê¸°ì¤€ ì¸ë±ìŠ¤/ì´ê³„ í‘œê¸°ë¡œ ë³€ê²½ (ì˜ˆ: 10.82.104.201:19776 (1/9))
    function nodeCellHtml(n, procIndex, procTotal){
      const href = `/proxy/${encodeURIComponent(n.name)}/dms-system.html`;
      const suffix = (typeof procIndex === "number" && typeof procTotal === "number" && procTotal>0)
        ? ` (${procIndex+1}/${procTotal})` : "";
      return `<a class="node" href="${href}" target="_blank">${(n.alias||n.name)}</a><br><span class="muted">${n.host}:${n.port}${suffix}</span>`;
    }

    function applyOverlays(data){
      const extra   = (data && data.extra) || {};
      const verMap  = extra.versions || {};
      const presdVer= extra.presd_versions || {};
      const conn    = extra.connected_daemons || {};
      const presdIps= extra.presd_ips || [];
      const nodes   = Array.isArray(data.nodes) ? data.nodes : [];

      const ipFromHost = (s)=>{
        const m = String(s||"").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s||"");
      };
      const toList = (status)=>{
        if (!status) return [];
        if (status.data && typeof status.data==="object") return Object.values(status.data);
        if (Array.isArray(status.processes)) return status.processes;
        if (Array.isArray(status.executables)) return status.executables;
        return [];
      };
      const hasNonDash = v => (typeof v === "string") ? v.trim() !== "-" && v.trim() !== "" : !!v;

      for (const n of nodes){
        const nodeIp = ipFromHost(n.host);
        const procs = toList(n.status);
        for (const p of procs){
          if (!p || !p.name) continue;

          // ---- (1) ë²„ì „ ì˜¤ë²„ë ˆì´ ----
          if (p.name === "PreSd"){
            const src =
              presdVer[nodeIp] ||
              (verMap.PreSd && (verMap.PreSd[nodeIp] || (verMap.PreSd.byIp && verMap.PreSd.byIp[nodeIp]))) ||
              null;
            if (src){
              p.version = src.version || "-";
              p.version_date = src.date || "-";
            } else if (verMap.PreSd && verMap.PreSd.version) {
              // fallback (ì§‘ê³„í˜•)
              p.version = verMap.PreSd.version || "-";
              p.version_date = verMap.PreSd.date || "-";
            }
          } else if (p.name === "MMd" && verMap.MMd){
            p.version = verMap.MMd.version || "-";
            p.version_date = verMap.MMd.date || "-";
          } else if (verMap[p.name]){
            p.version = verMap[p.name].version || "-";
            p.version_date = verMap[p.name].date || "-";
          }

          // ---- (2) PCd connect ì‘ë‹µ ê¸°ë°˜ CONNECTED íŒì •ë§Œ ì ìš© ----
          // ì¼ë°˜ ë°ëª¬
          if (conn && typeof conn === "object" && conn[p.name] === true){
            p.connection_state = "CONNECTED";
          }
          // PreSdëŠ” IPë³„ í—ˆìš© ëª©ë¡
          if (p.name === "PreSd" && conn && conn.PreSd === true){
            if (!presdIps.length || presdIps.includes(nodeIp)){
              p.connection_state = "CONNECTED";
            }
          }
        }
      }
    }
    function render(data){
      applyOverlays(data);
      OMS_ALIAS_MAP = (data && data.extra && data.extra.alias_map) || {};
      lastData=data;

      const hbSecRaw = Number(data && data.heartbeat_interval_sec);

      // Aì•ˆ: versions / presd_versionsë¥¼ í•œ ë²ˆ êº¼ë‚´ì„œ í‘œ ë Œë”ë§ì— ì‚¬ìš©
      const VERS = (data && data.extra && data.extra.versions) || {};
      const PRESD_VERS = (data && data.extra && data.extra.presd_versions) || {};
      // í´ë°±ìš© ì „ì—­ ì €ì¥(ì„ íƒ)
      window.__omsLastState = window.__omsLastState || {};
      window.__omsLastState.versions = VERS;
      window.__omsLastState.presd_versions = PRESD_VERS;
      // ë…¸ë“œì˜ host ë¬¸ìì—´ì—ì„œ IPë§Œ ì¶”ì¶œ
      const ipOf = (s)=>{
        const m = String(s||"").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s||"");
      };

      if (!Number.isNaN(hbSecRaw) && hbSecRaw > 0) {
        const nextMs = Math.max(800, Math.min(10000, Math.floor(hbSecRaw * 1000)));
        if (!RA_LOCK && nextMs !== POLL_MS) {
          startPolling(nextMs);
        }
        HB.textContent = `poll ${hbSecRaw}s`;
      } else {
        HB.textContent = "poll -";
      }

      const nodes = Array.isArray(data.nodes)? data.nodes : [];
      // ì „ì²´ ì„ íƒëœ í”„ë¡œì„¸ìŠ¤ ê°œìˆ˜ ê³„ì‚° (executables.select ê¸°ì¤€)
      let procTotal = 0;
      for (const _n of nodes){
        const _sel = selectedProcList(_n.status);
        procTotal += _sel.length;
      }
      const bullet = "\u2022";
      META.textContent = `nodes: ${nodes.length} ${bullet} processes: ${procTotal}`;
      TBody.innerHTML="";
      if (nodes.length===0){
        TBody.innerHTML = `<tr class="other"><td colspan="5" class="muted">no nodes</td></tr>`; return;
      }
      for(let i=0;i<nodes.length;i++){
        const n=nodes[i];
        const shown = selectedProcList(n.status);
        if (!n.status){
          TBody.insertAdjacentHTML("beforeend", `<tr class="other"><td>${nodeCellHtml(n,0,0)}</td><td colspan="4" class="muted">unreachable</td></tr>`); continue;
        }
        if (shown.length===0){
          TBody.insertAdjacentHTML("beforeend", `<tr class="other"><td>${nodeCellHtml(n,0,0)}</td><td colspan="4" class="muted">no selected processes</td></tr>`); continue;
        }
        for(let j=0;j<shown.length;j++){
          const p = shown[j];
          const running = !!p.running;
          // Aì•ˆ: í–‰ë§ˆë‹¤ ë²„ì „ í…ìŠ¤íŠ¸ë¥¼ versions ë§µì—ì„œ ê³„ì‚°
          const nodeIp = ipOf(n.host);
          // NOTE: PreSdëŠ” IPë³„ ë²„ì „ì´ë¯€ë¡œ ì™¸ë¶€ resolveVersionì„ ì“°ì§€ ì•Šê³  ë¡œì»¬ ë§µì„ ì§ì ‘ ì°¸ì¡°í•œë‹¤.
          const _rv = (proc, ip) => {
            // applyOverlaysì—ì„œ p.version/p.version_dateë¥¼ ë„£ì–´ì¤¬ë‹¤ë©´ ê·¸ê²ƒì„ ìµœìš°ì„  ì‚¬ìš©
            if (p && typeof p.version === "string" && p.version.trim()) return p.version;
            if (proc === "PreSd") {
              return (PRESD_VERS[ip]?.version)
                   || (VERS.PreSd?.[ip]?.version)
                   || (VERS.PreSd?.byIp?.[ip]?.version)
                   || (VERS.PreSd?.version)
                   || "-";
            }
            return (VERS[proc]?.version) || "-";
          };   
          const conn=(p.connection_state||"").toUpperCase();
          const badge =
            conn === "CONNECTED" ? `<span class="pill badge-connected">CONNECTED</span>` :
            conn === "STOPPED"   ? `<span class="pill badge-bad">STOPPED</span>` :
            (running ? `<span class="pill badge-running">RUNNING</span>` : `<span class="pill badge-bad">STOPPED</span>`);          // ë‚ ì§œëŠ” ì„œë²„ê°€ dateë¥¼ í•¨ê»˜ ë‚´ë ¤ì¤„ ë•Œë§Œ í‘œì‹œ(PreSdëŠ” IPë³„ date ì§€ì›)
          const rowIsRunning = running || conn === "CONNECTED";
          const verText = _rv(p.name, nodeIp);
          const dateText = (p && typeof p.version_date === "string" && p.version_date.trim())
            ? p.version_date
            : (p.name === "PreSd"
                ? (PRESD_VERS[nodeIp]?.date
                   || VERS.PreSd?.[nodeIp]?.date
                   || VERS.PreSd?.byIp?.[nodeIp]?.date
                   || VERS.PreSd?.date
                   || "-")
                : (VERS[p.name]?.date || "-"));
          const verHtml = `${verText}<br><span class="muted">${dateText}</span>`;
          const dmsAlias = (p.alias || "").trim();
          const omsAlias = (OMS_ALIAS_MAP[p.name] || "").trim();
          let aliasHtml = "";
          if (dmsAlias && omsAlias && dmsAlias !== omsAlias) {
            aliasHtml = `<br><span class="muted" title="OMS alias: ${omsAlias}">${dmsAlias}</span>`;
          } else {
            const a = dmsAlias || omsAlias;
            aliasHtml = a ? `<br><span class="muted">${a}</span>` : "";
          }

          TBody.insertAdjacentHTML("beforeend", `
            <tr class="${rowIsRunning ? 'running' : 'other'}">
              <td>${nodeCellHtml(n, j, shown.length)}</td>
              <td>${p.name||"-"}${aliasHtml}</td>
              <td>${verHtml}</td>
              <td>${badge}</td>
              <td>
                <button class="btn-secondary" data-a="logs"  data-node="${n.name}" data-proc="${p.name}">ğŸ“œ Logs</button>
              </td>
            </tr>`);
        }
      }
    }

    async function reloadNow(){
      try{
        if (!RA_LOCK) setBusy(true);
        clearErr();
        render(await api("/oms/status"));
      }catch(e){
        showErr(e.message||e);
      }finally{
        if (!RA_LOCK) setBusy(false);
      }
    }

    document.querySelector("#grid tbody").addEventListener("click", ev=>{
      const b=ev.target.closest("button"); if(!b) return;
      if (b.dataset.a==="logs"){
        const url = `/web/log-viewer.html?node=${encodeURIComponent(b.dataset.node)}&name=${encodeURIComponent(b.dataset.proc)}`;
        window.open(url,"_blank");
      }
    });

    // ==== Restart-All ì§„í–‰ ì¹´ìš´íŒ… & ë¼ì´ë¸Œ ì§„í–‰ì¹© ê°±ì‹  ====
    function pluckProcs(status){
      if (!status) return [];
      if (status.data && typeof status.data==="object") return Object.values(status.data);
      if (Array.isArray(status.processes)) return status.processes;
      if (Array.isArray(status.executables)) return status.executables;
      return [];
    }
    function calcProgressFromOmsStatus(omsStatus){
      const nodes = Array.isArray(omsStatus && omsStatus.nodes) ? omsStatus.nodes : [];
      let total=0, run=0, stop=0;
      for (const n of nodes){
        const list = selectedProcList(n && n.status);
        for (const p of list){
          total += 1;
          if (p.running) run += 1; else stop += 1;
        }
      }
      return { total, run, stop, unknown: 0 };
    }
    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));

    let RA_LIVE = null;
    async function startRaLiveProgressLoop(){
      stopRaLiveProgressLoop();
      RA_LIVE = setInterval(async ()=>{
        try{
          const data = await api("/oms/status");
          const p = calcProgressFromOmsStatus(data);
          const sec = Math.round((performance.now() - (window.__raStartTs||performance.now()))/1000);
          if (p.total > 0){
            raWrite(`Restartingâ€¦ (${p.run}/${p.total} running Â· ${p.stop}/${p.total} stopped Â· ${sec}s)`, 2);
          }else{
            raWrite(`Restartingâ€¦ (discovering Â· ${sec}s)`, 2);
          }
        }catch{}
      }, 600);
    }
    function stopRaLiveProgressLoop(){
      if (RA_LIVE){ clearInterval(RA_LIVE); RA_LIVE = null; }
    }

    // ==== SSE & í´ë°± í´ë§ ====
    let evtSrc=null, sseTimer=null, statePoller=null;
    function closeSSE(){ if(evtSrc){evtSrc.close(); evtSrc=null;} if(sseTimer){clearInterval(sseTimer); sseTimer=null;} }
    function onProgressState(s){
      if (!s) return;
      if (s.message) raWrite(s.message, 3);
      // running ì‹ í˜¸ ê°ì§€ â†’ ì´í›„ì—ë§Œ ì™„ë£Œ ì¸ì •
      if (s.state === "running") {
        RA_SEEN_RUNNING = true;
        return;
      }

      // í´ë¦­ ì§í›„ idleì€ ì¡°ê¸° ì™„ë£Œë¡œ ì˜¤ì¸ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìœ ì˜ˆ
      if (s.state === "idle" && !RA_SEEN_RUNNING) {
        const elapsed = performance.now() - (window.__raStartTs || performance.now());
        if (elapsed < RA_IDLE_GRACE_MS) {
          // ì¡°ìš©íˆ ë¬´ì‹œí•˜ê±°ë‚˜ ê°€ë²¼ìš´ ëŒ€ê¸° ë©”ì‹œì§€
          raWrite(`Waiting to startâ€¦ (${Math.max(1, Math.round((RA_IDLE_GRACE_MS - elapsed)/1000))}s)`, 2);
          return;
        }
        // ìœ ì˜ˆ í›„ì—ë„ runningì„ ëª» ë´¤ë‹¤ë©´ "ì§„í–‰ ì—†ìŒ"ìœ¼ë¡œ ì•ˆë‚´ë§Œ í•˜ê³  ì™„ë£Œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
        raWrite("No restart in progress (idle).", 2);
        return;
      }
      if (s.state==="done" || s.state==="error" || (s.state==="idle" && RA_SEEN_RUNNING)){         
        // ì™„ë£Œ ì²˜ë¦¬: ëª¨ë“  ì‘ì„±ì ì •ì§€ + ìµœì¢… ë©”ì‹œì§€ ê³ ì •
        RA_FINAL = true;
        stopRaProgressPolling();
        stopRaLiveProgressLoop();
        closeSSE();

        RA_LOCK = false; setBusy(false);
        // ì„œë²„ ìš”ì•½ ìš°ì„ 
        if (s.summary && typeof s.summary === "object"){
          const sum = s.summary;
          const took = (sum.elapsedSec!=null) ? `${Math.round(sum.elapsedSec)}s`
                    : `${Math.round((performance.now() - (window.__raStartTs||performance.now()))/1000)}s`;
          const stopOk = sum.stop?.ok ?? 0, stopFail = sum.stop?.fail ?? 0;
          const startOk = sum.start?.ok ?? 0, startFail = sum.start?.fail ?? 0;
          raWrite(`Restart-All done: stop ok ${stopOk}, fail ${stopFail}; start ok ${startOk}, fail ${startFail}; elapsed ${took}`, 10);
          if ((sum.stop?.fail||0) + (sum.start?.fail||0) > 0 && Array.isArray(sum.failedNames) && sum.failedNames.length){
            showErr("Restart-All partial failures: " + sum.failedNames.join(", "));
          }
        } else {
          // ì„œë²„ ìš”ì•½ì´ ì—†ìœ¼ë©´ ë¼ì´ë¸Œ ìŠ¤ëƒ…ìƒ·ìœ¼ë¡œ ì„ì‹œ ìš”ì•½
          (async ()=>{
            try{
              const snap = await api("/oms/status");
              const p = calcProgressFromOmsStatus(snap);
              const took = `${Math.round((performance.now() - (window.__raStartTs||performance.now()))/1000)}s`;
              const fails = Math.max(0, p.total - p.run);
              const label = RA_SEEN_RUNNING ? "Restart-All done (live)" : "Restart-All finished (no activity)";
              raWrite(`${label}: start ok ${p.run}, fail ${fails}; elapsed ${took}`, 10);
              if (fails > 0){
                // ì‹¤íŒ¨ êµ¬ì²´ ëª©ë¡ì€ ì„œë²„ì—ì„œ ì œê³µë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ìƒëµ(ì›í•˜ë©´ /oms/restart/state í™•ì¥ í•„ìš”)
              }
            }catch{
              raWrite("Restart-All done", 10);
            }
          })();
        }

        startPolling(POLL_MS);
        if (statePoller){ clearInterval(statePoller); statePoller=null; }
        reloadNow().catch(()=>{});
      }
    }
    function startSSE(){
      closeSSE();
      if ("EventSource" in window){
        evtSrc = new EventSource(API + "/oms/restart/stream");
        // ì„œë²„ëŠ” event: progress ì‚¬ìš© â†’ ì •í™• ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        const handler = (e)=>{ try{ onProgressState(JSON.parse(e.data)); }catch{} };
        evtSrc.addEventListener("progress", handler);
        // í˜¹ì‹œ ë°°í¬ì— ë”°ë¼ ê¸°ë³¸ onmessageë¡œ ì˜¬ ìˆ˜ë„ ìˆì–´ì„œ ë°±ì—… ìœ ì§€
        evtSrc.onmessage = handler;
        evtSrc.onerror = ()=>{ startStatePolling(); };
      } else {
        startStatePolling();
      }
    }
    function startStatePolling(){
      // í•­ìƒ ë³´ì¡° í´ëŸ¬ë¥¼ ì¼ ë‹¤(= SSE ìœ ë¬´ì™€ ë¬´ê´€)
      if (statePoller) clearInterval(statePoller);
      statePoller = setInterval(async ()=>{
        try{
          const [s, st] = await Promise.all([
            api("/oms/restart/state"),
            api("/oms/status").catch(()=>null)
          ]);
          // ìƒíƒœ ìˆ«ì ë¶™ì—¬ì„œ ê°•ì œ ì§„í–‰ ë¬¸êµ¬ ì¶œë ¥
          if (st){
            const p = calcProgressFromOmsStatus(st);
            const base = (s && s.message) ? s.message : "Restartingâ€¦";
            raWrite(`${base} (${p.run}/${p.total} running Â· ${p.stop}/${p.total} stopped)`, 3);
          }else if (s && s.message){
            raWrite(s.message, 3);
          }
          onProgressState(s);
        }catch(_){}
      }, 700);
    }

    BTN_RELOAD.onclick = reloadNow;
    BTN_CONFIG.onclick = ()=> location.href="oms-config.html";
    BTN_RA.onclick = async ()=>{
      const mySession = ++RA_SESSION_ID;
      RA_LOCK = true;
      RA_FINAL = false;
      RA_MSG_PRIORITY = 0;
      RA_SEEN_RUNNING = false;
      stopPolling();
      clearErr(); setBusy(true);
      raWrite("Restartingâ€¦ preparing", 1);
      window.__raStartTs = performance.now();
      try{
        await api("/oms/restart/all", {method:"POST"});
        startStatePolling();
        // ì„œë²„ê°€ state=running ìœ¼ë¡œ ì „í™˜í•  ìœ ì˜ˆ
        setTimeout(() => {
          if (mySession !== RA_SESSION_ID) return; // ì˜¤ë˜ëœ ì„¸ì…˜ ë³´í˜¸
          startRaLiveProgressLoop();
          startSSE();
          startRaProgressPolling();
          // ë§Œì•½ SSEê°€ ì¡°ìš©í•˜ë©´(ë©”ì‹œì§€ ë¯¸ìˆ˜ì‹ ) í´ë°± ìƒíƒœ í´ë§ì„ ìë™ ì‹œì‘
          setTimeout(() => {
            if (mySession !== RA_SESSION_ID || RA_FINAL) return;            
          }, 1200);
        }, 250);
      }catch(e){
        showErr(e.message||e);
        RA_LOCK=false; setBusy(false); startPolling(POLL_MS);
        stopRaProgressPolling();
        stopRaLiveProgressLoop();
        if (statePoller){ clearInterval(statePoller); statePoller=null; }
      }
    };

    // ===== Connect Sequence bindings =====
    if (SEQ?.btnFill){
      SEQ.btnFill.onclick = ()=>{
        try{
          if (!lastData) { appendLog("No status yet. Click Reload first."); return; }
          const dm = {};
          // ê°€ì¥ ë‹¨ìˆœí•œ ì±„ìš°ê¸°: ê° í”„ë¡œì„¸ìŠ¤ ì´ë¦„ì˜ ìµœì´ˆ ë“±ì¥ ë…¸ë“œì˜ hostë¥¼ ë§¤í•‘
          for (const n of (lastData.nodes||[])){
            const host = n.host;
            const list = (n.status && (n.status.data ? Object.values(n.status.data)
                              : (n.status.processes || n.status.executables))) || [];
            for (const p of (list||[])){
              if (!p?.name) continue;
              if (dm[p.name]) continue;
              dm[p.name] = host;
            }
          }
          SEQ.mapArea.value = JSON.stringify(dm, null, 2);
          appendLog("Filled Daemon Map from current list.", dm);
        }catch(e){ appendLog("Fill failed", {error:String(e)}); }
      };
    }
    if (SEQ?.btnStart){
      SEQ.btnStart.onclick = async ()=>{
        SEQ_ABORT = false;
        try{
          SEQ.log.textContent = "-";
          seqSetStatus("Running", "pill-ok");
          appendLog("== step1: EMd connect(run) ==");
          const dm0 = parseDaemonMap();
          const dm  = SEQ.sanitize?.checked ? sanitizeDaemonMap(dm0) : sanitizeDaemonMap(dm0);
          const payload = {
            mtd_host: (SEQ.host?.value||"").trim(),
            mtd_port: Number(SEQ.port?.value||19765),
            dmpdip:   (SEQ.mgmt?.value||"").trim(),
            daemon_map: dm,
            trace: !!SEQ.verbose?.checked,   // ê¸°ë³¸ false
            return_partial: true,
            dry_run: !!SEQ.dryRun?.checked
          };
          const res = await api("/oms/connect/sequence", {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify(payload)
          });
          if (res?.events){
            for (const ev of res.events){
              if (SEQ_ABORT) break;
              const head = ev.step || "(step)";
              if (ev.error){
                appendLog(`${head} -> ERROR`, ev.error);
              }else{
                appendLog(`${head} -> OK`, ev.response ?? ev);
              }
            }
            appendLog("Sequence finished.", {ok:true});
            seqSetStatus("Done", "pill-ok");
          }else{
            appendLog("No events returned.", res);
            seqSetStatus("Done", "pill-warn");
          }
        }catch(e){
          appendLog("Sequence failed", {error:String(e)});
          seqSetStatus("Error", "pill-bad");
        }
      };
    }
    if (SEQ?.btnAbort){
      SEQ.btnAbort.onclick = ()=>{ SEQ_ABORT = true; appendLog("Abort requested."); seqSetStatus("Aborted","pill-warn"); };
    }
    if (SEQ?.btnCopy){
      SEQ.btnCopy.onclick = async ()=>{
        try{
          await navigator.clipboard.writeText(SEQ.log.textContent||"");
          appendLog("Copied log to clipboard.");
        }catch(e){ appendLog("Copy failed", {error:String(e)}); }
      };
    }
    if (SEQ?.btnSave){
      SEQ.btnSave.onclick = ()=>{
        const blob = new Blob([SEQ.log.textContent||""], {type:"text/plain;charset=utf-8"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `connect_sequence_${Date.now()}.log`;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
        appendLog("Saved log file.");
      };
    }    

    (async function(){
      try{
        const s = await api("/oms/restart/state");
        if (s && s.state === "running"){
          RA_LOCK=true; setBusy(true);
          raWrite(s.message || "Workingâ€¦", 3);
          window.__raStartTs = performance.now();
          startRaLiveProgressLoop();
          startSSE();
          RA_SEEN_RUNNING = true;
        }
      }catch{}
      await reloadNow();
      startPolling(POLL_MS);
    })();
  </script>

  <script src="/web/oms-system.js" defer></script>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      if (typeof window.initOmsSystem !== 'function') {
        console.error('initOmsSystem not found'); return;
      }
      window.initOmsSystem({});
    });
  </script>
</body>
</html>
