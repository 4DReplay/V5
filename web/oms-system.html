<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>4DReplay V5 - OMs System</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <link rel="icon" type="image/x-icon" href="web/images/4DMain.ico">

  <!-- proxy-safe asset loader: works for /proxy/<node>/... and direct port -->
  <script>
    (function () {
      // /proxy/<node>/... í™˜ê²½ì—ì„œë„ ë™ì‘
      const m = location.pathname.match(/^\/proxy\/([^/]+)/);
      const PROXY = m ? "/proxy/" + encodeURIComponent(m[1]) : "";
      const bust = "?v=" + Date.now();

      const ACTIONS_CANDIDATES = [
        PROXY + "/web/oms-actions.js",
        "./web/oms-actions.js",
        "./oms-actions.js",
        "/web/oms-actions.js"
      ];

      function injectJS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("script");
        el.defer = true;
        el.src = list[i] + bust;
        el.onerror = () => {
          console.warn("[OMS actions miss]", list[i]);
          injectJS(list, i + 1);
        };
        document.head.appendChild(el);
      }
      injectJS(ACTIONS_CANDIDATES);
    })();
  </script>
  
  <!-- e.g., /proxy/DMS-1/oms-system.html  =>  /proxy/DMS-1 -->
  <script>
    (function () {
      // e.g., /proxy/DMS-1/oms-system.html  =>  /proxy/DMS-1
      const m = location.pathname.match(/^\/proxy\/([^/]+)/);
      const PROXY_PREFIX = m ? "/proxy/" + encodeURIComponent(m[1]) : "";
      const bust = "?v=" + Date.now(); // cache-buster to avoid stale css/js

      const CSS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.css",
        "./4d-common-style.css",
      ];
      const JS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.js",
        "./4d-common-style.js",
      ];

      function injectCSS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("link");
        el.rel = "stylesheet"; el.href = list[i] + bust;
        el.onerror = () => { console.warn("[CSS miss]", list[i]); injectCSS(list, i + 1); };
        document.head.appendChild(el);
      }
      function injectJS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("script");
        el.defer = true; el.src = list[i] + bust;
        el.onerror = () => { console.warn("[JS miss]", list[i]); injectJS(list, i + 1); };
        document.head.appendChild(el);
      }
      injectCSS(CSS_CANDIDATES);
      injectJS(JS_CANDIDATES);
    })();
  </script>
</head>


<!----------------------------------------------------------------------------------
BODY
------------------------------------------------------------------------------------>
<body>
  <h2 class="page-title">
    <span id="pageTitle">4DReplay V5 - OMs System</span>
    <small id="meta"></small>
  </h2>

  <div class="toolbar">
    <button id="btnDashboard">ğŸ“Š Dashboard</button>
    <span class="divider"></span>
    <button id="btnSysRestart" class="btn-secondary">âŸ³ Restart All</button>
    <span class="divider"></span>
    <button id="btnSysConnect" class="btn-secondary">ğŸ”Œ Connect</button>
    <span class="divider"></span>
    <button id="btnSysConfig" class="btn-secondary">ğŸ“ Config Editor</button>
    <button id="btnSysReload" class="btn-secondary">ğŸ”„ Reload</button>    
    <span id="progressChip" class="chip" role="status" aria-live="polite"></span>
    <span class="spacer"></span>
    <span class="chip" id="hb">poll -</span>
  </div>
  <div id="err">    
  </div>
  <table id="grid">
    <thead>
      <tr>
        <th>Node</th>
        <th>Process</th>
        <th>Version</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <p class="muted" style="margin-top:10px">
    Tip: Clicking the title of each node allows you to manage the system.
  </p>  
  <script>
    const DEBUG = false;
    const TBody = document.querySelector("#grid tbody");
    const HB = document.getElementById("hb");
    const META = document.getElementById("meta");
    const PROG = document.getElementById("progressChip");
    const ERR = document.getElementById("err");
    const BTN_DASHBOARD   = document.getElementById("btnDashboard");
    const BTN_CONFIG      = document.getElementById("btnSysConfig");
    const BTN_SYS_RESTART = document.getElementById("btnSysRestart");
    const BTN_SYS_CONNECT = document.getElementById("btnSysConnect");
    const BTN_SYS_RELOAD  = document.getElementById("btnSysReload");    
    const PROG_LS_KEY = "oms_ra_progress"; // dashboardì™€ ë™ì¼ í‚¤

    /* â”€â”€ ì§„í–‰ ë©”ì‹œì§€/ìºì‹œë¥¼ ì™„ì „íˆ ë¹„ìš°ëŠ” helper â”€â”€ */
    function clearProgressChip() {
      try {
        localStorage.removeItem(PROG_LS_KEY);
      } catch (e) {
        console.warn("clearProgressChip localStorage error", e);
      }
      if (PROG) {
        PROG.textContent = "";
        PROG.style.visibility = "hidden";
      }
    }

    let lastData = null;
    let OMS_ALIAS_MAP = {};
    let POLLER = null;
    let POLL_MS = 3000;

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Proxy-safe API prefix (works with /proxy/<node>/â€¦) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const __PROXY_PREFIX__ = (() => {
      const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
      return m ? "/proxy/" + encodeURIComponent(decodeURIComponent(m[1])) : "";
    })();
    function api(path, init = {}) {
      const PFX = (typeof window !== "undefined" && window.__OMS_API_PREFIX__) || __PROXY_PREFIX__ || "";
      const url = (typeof path === "string" && path.startsWith("/")) ? (PFX + path) : path;
      return fetch(url, { cache: "no-store", ...init }).then(async (res) => {
        const ct = res.headers.get("content-type") || "";
        const isJson = ct.includes("application/json");
        const body = isJson ? await res.json().catch(() => ({})) : await res.text().catch(() => "");
        if (!res.ok) throw new Error(isJson ? (body.error || ("HTTP " + res.status)) : (body || ("HTTP " + res.status)));
        return body;
      });
    }

    function showErr(m) { ERR.style.display = "block"; ERR.textContent = m; }
    function clearErr() { ERR.style.display = "none"; ERR.textContent = ""; }

    function setBusy(on) {
      console.log("setBusy")
      BTN_SYS_RELOAD.disabled = !!on;
      BTN_CONFIG.disabled = !!on;
      BTN_SYS_RESTART.disabled = !!on;
      BTN_SYS_CONNECT.disabled = !!on;
    }

    function startPolling(ms) {
      if (typeof ms === "number" && isFinite(ms) && ms > 0) {
        POLL_MS = ms;
      }
      if (POLLER) clearInterval(POLLER);
      POLLER = setInterval(() => {
        reloadNow({ silent: true }).catch(() => {});
      }, POLL_MS);
      if (DEBUG) console.debug("[OMS] poll started:", POLL_MS, "ms");
    }
    function stopPolling() {
      if (POLLER) {
        clearInterval(POLLER);
        POLLER = null;
      }
    }
    function toProcList(status) {
      if (!status) return [];
      if (status.data && typeof status.data === "object") return Object.values(status.data);
      if (Array.isArray(status.processes)) return status.processes;
      if (Array.isArray(status.executables)) return status.executables;
      return [];
    }
    // ì„ íƒ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ë¦¬ìŠ¤íŠ¸ (dms-system ê·œì¹™ê³¼ ë™ì¼í•˜ê²Œ executables.select=true ê¸°ì¤€)
    function selectedProcList(status) {
      if (!status) return [];
      const execs = Array.isArray(status.executables) ? status.executables : [];
      const procs = Array.isArray(status.processes) ? status.processes : [];
      const dataObjs = (status.data && typeof status.data === "object") ? Object.values(status.data) : [];

      const stateMap = Object.create(null);
      const ingest = (arr) => {
        for (const x of (arr || [])) {
          if (!x) continue;
          const nm = x.name || x.proc || x.id;
          if (!nm) continue;
          stateMap[nm] = { ...(stateMap[nm] || {}), ...x, name: nm };
        }
      };
      ingest(procs);
      ingest(execs);
      ingest(dataObjs);

      const normRunning = (v) => {
        if (typeof v === "boolean") return v;
        const s = String(v || "").trim().toLowerCase();
        return s === "running" || s === "started";
      };

      const base = execs.length ? execs : (procs.length ? procs : dataObjs);
      return base
        .filter(e => e && (e.select !== false))
        .map(e => {
          const nm = e.name || e.proc || e.id;
          const ref = stateMap[nm] || {};
          const running = normRunning(ref.running ?? ref.status ?? e.running ?? e.status);
          return {
            name: nm,
            alias: e.alias || ref.alias || "",
            select: e.select !== false,
            running,
            connection_state: ref.connection_state || e.connection_state || null,
            version: ref.version || e.version,
            version_date: ref.version_date || e.version_date,
          };
        });
    }
    function nodeCellHtml(n, procIndex, procTotal) {
      const href = "/proxy/" + encodeURIComponent(n.name) + "/dms-system.html";
      const suffix = (typeof procIndex === "number" && typeof procTotal === "number" && procTotal > 0)
        ? " (" + (procIndex + 1) + "/" + procTotal + ")" : "";

      return `
        <a class="node" href="${href}">${n.alias || n.name}</a><br>
        <span class="muted">${n.host}:${n.port}${suffix}</span>
      `;
    }
    function applyOverlays(data) {
      const extra = (data && data.extra) || {};
      const verMap = extra.versions || {};
      const presdVer = extra.presd_versions || {};
      const aicVer = extra.aic_versions || {};                     // â˜… ì¶”ê°€
      const conn = extra.connected_daemons || {};
      const presdIps = Array.isArray(extra.presd_ips)              // â˜… ë°°ì—´ ë³´ì¥
        ? extra.presd_ips
        : [];
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];

      const ipFromHost = (s) => {
        const m = String(s || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s || "");
      };
      const listFromStatus = (status) => {
        if (!status) return [];
        if (status.data && typeof status.data === "object") return Object.values(status.data);
        if (Array.isArray(status.processes)) return status.processes;
        if (Array.isArray(status.executables)) return status.executables;
        return [];
      };

      for (const n of nodes) {
        const nodeIp = ipFromHost(n.host);
        const procs = listFromStatus(n.status);
        for (const p of procs) {
          if (!p || !p.name) continue;

          // â”€â”€ AIc ë²„ì „ ì˜¤ë²„ë ˆì´ (ip / process ê¸°ë°˜)
          if (p.name === "AIc" && aicVer) {
            const alias = (p.alias || "").trim();
            let src = null;

            // aic_versions êµ¬ì¡°: { "<ip>": { "<proc_or_alias>": {version,date}, ... }, ... }
            for (const [ip, byName] of Object.entries(aicVer)) {
              if (!byName || typeof byName !== "object") continue;
              if (alias && alias in byName) {
                src = byName[alias];
                break;
              }
            }

            // alias ë¡œ ëª» ì°¾ì•˜ìœ¼ë©´, ë…¸ë“œ IP + "AIc" ì´ë¦„ìœ¼ë¡œ í•œ ë²ˆ ë” ì‹œë„
            if (!src) {
              const byName = aicVer[nodeIp];
              if (byName && typeof byName === "object" && byName["AIc"]) {
                src = byName["AIc"];
              }
            }

            if (src) {
              p.version = src.version || "-";
              p.version_date = src.date || "-";
            }
          }

          // â”€â”€ PreSd ë²„ì „ ì˜¤ë²„ë ˆì´
          if (p.name === "PreSd") {
            const src =
              presdVer[nodeIp] ||
              (verMap.PreSd && (verMap.PreSd[nodeIp] || (verMap.PreSd.byIp && verMap.PreSd.byIp[nodeIp]))) ||
              null;
            if (src) {
              p.version = src.version || "-";
              p.version_date = src.date || "-";
            } else if (verMap.PreSd && verMap.PreSd.version) {
              p.version = verMap.PreSd.version || "-";
              p.version_date = verMap.PreSd.date || "-";
            }
          } else if (verMap[p.name]) {
            p.version = verMap[p.name].version || p.version || "-";
            p.version_date = verMap[p.name].date || p.version_date || "-";
          }

          // â”€â”€ CONNECTED ì˜¤ë²„ë ˆì´
          if (conn && conn[p.name] === true) {
            if (p.name === "PreSd") {
              const ipOk = !presdIps.length || presdIps.includes(nodeIp);
              if (ipOk) p.connection_state = "CONNECTED";
            } else {
              p.connection_state = "CONNECTED";
            }
          }
        }
      }

      // alias_map ì „ë‹¬
      OMS_ALIAS_MAP = extra.alias_map || {};
    }
    function effectiveStateOf(procObj) {
      if (!procObj) return "STOPPED";
      const running = !!procObj.running;
      const conn = String(procObj.connection_state || "").toUpperCase();
      if (!running) return "STOPPED";
      if (conn === "CONNECTED") return "CONNECTED";
      return "RUNNING";
    }
    function render(data) {
      if (!data) return;
      applyOverlays(data);
      lastData = data;
      
      const hbSecRaw = Number(data && data.heartbeat_interval_sec);
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];
      const summary = (data && data.summary) || {};

      if (!Number.isNaN(hbSecRaw) && hbSecRaw > 0) {
        const nextMs = Math.max(800, Math.min(10000, Math.floor(hbSecRaw * 1000)));
        if (nextMs !== POLL_MS) startPolling(nextMs);
        HB.textContent = "poll " + hbSecRaw + "s";
      } else {
        HB.textContent = "poll -";
      }

      TBody.innerHTML = "";
      if (nodes.length === 0) {
        const nodesCount      = summary.nodes      ?? 0;
        const processesCount  = summary.processes  ?? 0;
        const connectedCount  = summary.connected  ?? 0;
        const runningCount    = summary.running    ?? 0;
        const stoppedCount    = summary.stopped    ?? 0;
        META.textContent =
          `nodes: ${nodesCount} â€¢ processes: ${processesCount}` +
          ` ( connected: ${connectedCount} / running: ${runningCount} / stopped: ${stoppedCount} )`;
        TBody.innerHTML = '<tr class="other"><td colspan="5" class="muted">no nodes</td></tr>';
        return;
      }

      const VERS = (data && data.extra && data.extra.versions) || {};
      const PRESD_VERS = (data && data.extra && data.extra.presd_versions) || {};
      const ipOf = (s) => {
        const m = String(s || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s || "");
      };

      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        let shown = selectedProcList(n.status);
        
        if (!n.status) {
          TBody.insertAdjacentHTML("beforeend",
            '<tr class="other"><td>' + nodeCellHtml(n, 0, 0) + '</td><td colspan="4" class="muted">unreachable</td></tr>');
          continue;
        }

        if (shown.length === 0) {
          const fallback = toProcList(n.status).map(x => ({
            name: (x && (x.name || x.proc || x.id)) || "-",
            alias: (x && x.alias) || "",
            running: !!(x && (x.running || String(x.status || "").toLowerCase() === "running")),
            connection_state: (x && x.connection_state) || null,
            select: true
          }));
          if (fallback.length > 0) {
            shown = fallback;
          } else {
            TBody.insertAdjacentHTML("beforeend",
              '<tr class="other"><td>' + nodeCellHtml(n, 0, 0) + '</td><td colspan="4" class="muted">no processes</td></tr>');
            continue;
          }
        }

        for (let j = 0; j < shown.length; j++) {
          const p = shown[j];
          const nodeIp = ipOf(n.host);

          const _rv = (proc, ip) => {
            if (p && typeof p.version === "string" && p.version.trim()) return p.version;
            if (proc === "PreSd") {
              return (PRESD_VERS[ip]?.version)
                || (VERS.PreSd?.[ip]?.version)
                || (VERS.PreSd?.byIp?.[ip]?.version)
                || (VERS.PreSd?.version)
                || "-";
            }
            return (VERS[proc]?.version) || "-";
          };

          const eff = effectiveStateOf(p);
          const badge =
            eff === "STOPPED" ? '<span class="pill bad">STOPPED</span>' :
            eff === "CONNECTED" ? '<span class="pill connected">CONNECTED</span>' :
            '<span class="pill ok">RUNNING</span>';

          const rowCls = (eff === "STOPPED") ? "stopped" : "running";
          const verText = _rv(p.name, nodeIp);
          const dateText = (p && typeof p.version_date === "string" && p.version_date.trim())
            ? p.version_date
            : (p.name === "PreSd"
              ? (PRESD_VERS[nodeIp]?.date
                || VERS.PreSd?.[nodeIp]?.date
                || VERS.PreSd?.byIp?.[nodeIp]?.date
                || VERS.PreSd?.date
                || "-")
              : (VERS[p.name]?.date || "-"));
          const verHtml = verText + '<br><span class="muted">' + (dateText || "-") + "</span>";

          const dmsAlias = (p.alias || "").trim();
          const omsAlias = (OMS_ALIAS_MAP[p.name] || "").trim();
          let aliasHtml = "";
          if (dmsAlias && omsAlias && dmsAlias !== omsAlias) {
            aliasHtml = '<br><span class="muted" title="OMS alias: ' + omsAlias + '">' + dmsAlias + "</span>";
          } else {
            const a = dmsAlias || omsAlias;
            aliasHtml = a ? '<br><span class="muted">' + a + "</span>" : "";
          }

          TBody.insertAdjacentHTML("beforeend",
            '<tr class="' + rowCls + '">' +
              '<td>' + nodeCellHtml(n, j, shown.length) + "</td>" +
              '<td>' + (p.name || "-") + aliasHtml + "</td>" +
              '<td>' + verHtml + "</td>" +
              '<td>' + badge + "</td>" +
              '<td><button class="btn-secondary" data-a="logs" data-node="' +
                n.name + '" data-proc="' + p.name + '">ğŸ“œ Logs</button></td>' +
            "</tr>");
        }
      }

      const bullet = "\u2022";
      // âœ… summary ê¸°ì¤€ìœ¼ë¡œ ë©”íƒ€/ì´ë²¤íŠ¸ ë°˜ì˜ (ì—†ìœ¼ë©´ ìµœì†Œ fallback)
      const nodesCount      = summary.nodes      ?? nodes.length;
      const processesCount  = summary.processes  ?? 0;
      const connectedCount  = summary.connected  ?? 0;
      const runningCount    = summary.running    ?? 0;
      const stoppedCount    = summary.stopped    ?? 0;

      META.textContent =
        `nodes: ${nodesCount} â€¢ processes: ${processesCount} ( connected: ${connectedCount} / running: ${runningCount} / stopped: ${stoppedCount} )`;

      const OSM_SUMMARY = {
        // ê·¸ëŒ€ë¡œ summaryë¥¼ í˜ë ¤ë³´ë‚´ë˜, í•„ìˆ˜ê°’ ì—†ìœ¼ë©´ ìµœì†Œí•œì˜ fallback
        nodes: nodesCount,
        processes: processesCount,
        connected: connectedCount,
        running: runningCount,
        stopped: stoppedCount,
        ts: Date.now(),
        source: "oms-system"
      };
      try {
        window.OMS = window.OMS || {};
        window.OMS.summary = OSM_SUMMARY;
        window.dispatchEvent(new CustomEvent("oms:summary", { detail: OSM_SUMMARY }));
      } catch (e) {
        if (DEBUG) console.warn("oms:summary dispatch failed", e);
      }
    }

    async function reloadNow(opts = {}) {
      const silent = !!opts.silent;
      try {
        if (!silent) setBusy(true);
        clearErr();
        const data = await api("/oms/status");
        render(data);
      } catch (e) {
        showErr(e.message || String(e));
      } finally {
        if (!silent) setBusy(false);
      }
    }
    document.querySelector("#grid tbody").addEventListener("click", ev => {
      const b = ev.target.closest("button"); if (!b) return;
      if (b.dataset.a === "logs") {
        const url = "/web/log-viewer.html?node=" +
          encodeURIComponent(b.dataset.node) +
          "&name=" + encodeURIComponent(b.dataset.proc);
        window.open(url, "_blank");
      }
    });

    // ========================================================================
    // Button Action
    // ========================================================================
    
    // â”€ [Button] Reload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    BTN_SYS_RELOAD.onclick = () => reloadNow({ silent: false });
    // â”€ [Button] Restart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    BTN_SYS_RESTART.onclick = () => {
        // âœ… Restart ì‹œì‘ ì „ì— ì§€ë‚œ ì§„í–‰ ë©”ì‹œì§€ ì™„ì „íˆ ì‚­ì œ
        console.log("BTN_SYS_RESTART.onclick")
        clearProgressChip();

        window.OMS = window.OMS || {};
        window.OMS.Actions = window.OMS.Actions || {};
        const Actions = window.OMS.Actions;
    
        // JS helperê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ë¨¼ì € ì‚¬ìš©
        if (Actions && typeof Actions.sysRestart === "function") {
            Actions.sysRestart().catch(e => {
                const msg = String(e?.message || e || "");
                alert("Restart-All failed: " + msg);
            });
            return;
        }
      
        // fallback: ì§ì ‘ API í˜¸ì¶œ
        api("/oms/sys-restart/all", { method: "POST" })
            .catch(e => {
                const msg = String(e?.message || e || "");
                alert("Restart-All failed: " + msg);
            });
    };
    // â”€ [Button] Connect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    BTN_SYS_CONNECT.onclick = () => {
      // âœ… Connect ì‹œì‘ ì‹œì—ë„ ì§€ë‚œ ë©”ì‹œì§€ clear
      clearProgressChip();

      try {
        const Actions = window.OMS && window.OMS.Actions;
        if (!Actions || typeof Actions.sysConnect !== "function") {
          console.error("sysConnect not available");
          return;
        }

        const ret = Actions.sysConnect();
        // sysConnectê°€ async í•¨ìˆ˜ë¼ë©´ ì—¬ê¸°ì„œ Promiseë¥¼ ë°›ì„ ìˆ˜ ìˆìŒ
        if (ret && typeof ret.then === "function") {
          ret
            .then(() => {
              // Connect ì‘ì—… ëë‚œ ë’¤ ìµœì‹  ìƒíƒœë¡œ í•œ ë²ˆ ê°•ì œ ë¦¬ë¡œë“œ
              return reloadNow({ silent: false });
            })
            .catch((e) => {
              console.error("sysConnect failed", e);
              // ì‹¤íŒ¨í•´ë„ í•œë²ˆ ìƒíƒœëŠ” ë‹¤ì‹œ ì½ì–´ë³¼ ìˆ˜ ìˆìŒ
              reloadNow({ silent: false }).catch(() => {});
            });
        } else {
          // Promiseë¥¼ ì•ˆ ë¦¬í„´í•˜ëŠ” êµ¬ë²„ì „ êµ¬í˜„ì´ë¼ë©´,
          // ì•½ê°„ì˜ ë”œë ˆì´ í›„ì— í•œ ë²ˆ ìƒíƒœ ì¬ì¡°íšŒ
          setTimeout(() => {
            reloadNow({ silent: false }).catch(() => {});
          }, 2000);
        }
      } catch (e) {
        console.error(e);
      }
    };
    // â”€ [Button] Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    BTN_DASHBOARD.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      window.location.href = base + "/dashboard";
    };
    // â”€ [Button] Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    BTN_CONFIG.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      window.location.href = base + "/web/oms-config.html";
    };

    // í˜ì´ì§€ê°€ ì¤€ë¹„ë˜ë©´ actions ë ˆì´ì–´ì— hookê³¼ uië¥¼ ë„˜ê²¨ì¤€ë‹¤
    function mountActionsOnce() {
      if (!(window.OMS && window.OMS.Actions)) return;
      try {
        window.OMS.Actions.mountPage({
          hooks: {
            reloadNow: (opts) => reloadNow(opts),
            render: (data) => render(data)
          }
        });
        if (window.OMS.__ui && typeof window.OMS.Actions.setUi === "function") {
          window.OMS.Actions.setUi(window.OMS.__ui);
        }
      } catch (e) {
        console.error("mountPage failed", e);
      }
    }
    // ì´ˆê¸° ë¶€íŒ…: í•œ ë²ˆë§Œ ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œ
    (function bootstrap() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          reloadNow({ silent: false }).catch(e => console.error(e));
          startPolling(POLL_MS);
        });
      } else {
        reloadNow({ silent: false }).catch(e => console.error(e));
        startPolling(POLL_MS);
      }

      // Summary ì´ë²¤íŠ¸ë¡œ Title ì˜† metaë„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
      window.addEventListener("oms:summary", (ev) => {
          const d = ev.detail || {};
          const bullet = "\u2022";
          META.textContent =
            "nodes: " + (d.nodes || 0) + " " + bullet +
            " processes: " + (d.processes || 0) +
            " ( connected: " + (d.connected || 0) +
            " / running: " + (d.running || 0) +
            " / stopped: " + (d.stopped || 0) + " )";
      });

    })();

    // â”€ Restart Lock 
    (function syncRestartLock() {
      console.log("syncRestartLock")
      function applyLock(locked) {
        const on = !!locked;
        if (BTN_SYS_RESTART) BTN_SYS_RESTART.disabled = on;
        if (BTN_SYS_CONNECT) BTN_SYS_CONNECT.disabled = on;
      }

      // í˜ì´ì§€ ì§„ì… ì‹œ í˜„ì¬ lock ìƒíƒœ í•œ ë²ˆ ë°˜ì˜
      try {
        if (window.OMS && window.OMS.Actions && typeof window.OMS.Actions.isSysRestartLocked === "function") {
          applyLock(window.OMS.Actions.isSysRestartLocked());
        }
      } catch { }

      // BroadcastChannel ë¡œ ì‹¤ì‹œê°„ ë™ê¸°í™”
      try {
        const bc = new BroadcastChannel("oms-restart-lock");
        bc.onmessage = (e) => {
          if (!e || !e.data) return;
          applyLock(!!e.data.locked);
        };
      } catch { }
    })();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unified Progress Poller & Chip Sync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function getTitleChipEl() {
      // oms-systemì˜ chipì€ progressChip ì´ë‹¤
      return document.getElementById("progressChip");
    }

    (function unifiedProgressManager() {
      const KEY = PROG_LS_KEY;
      const INTERVAL = 1000;

      function applyLockFromMessage(msgRaw) {
        // debug
        console.log("applyLockFromMessage", msgRaw)

        const msg = String(msgRaw || "").trim().toLowerCase();
        if (!msg.startsWith("[system][restart]")) 
          return;

        BTN_SYS_RESTART.disabled = true;
        BTN_SYS_CONNECT.disabled = true;
        
        if (
          msg.includes("finished") ||
          /\b(finished|done|complete)\b/.test(msg) ||
          msg.includes("restart-all done") ||
          msg.includes("restart-all failed")
        ) {
          BTN_SYS_RESTART.disabled = false;
          BTN_SYS_CONNECT.disabled = false;
        }
      }

      // ìµœì´ˆ ìºì‹œ UI ë°˜ì˜
      try {
        const cached = localStorage.getItem(KEY);
        if (cached && PROG) {
          const msg = cached.trim();

          // debug
          console.log("unifiedProgressManager",msg)

          PROG.textContent = msg;
          PROG.style.visibility = msg ? "visible" : "hidden";
          applyLockFromMessage(msg);
        }
      } catch {}

      // ë‹¤ë¥¸ íƒ­ sync
      window.addEventListener("storage", (e) => {
        if (e.key !== KEY || typeof e.newValue !== "string") return;
        const msg = e.newValue.trim();
        PROG.textContent = msg;
        PROG.style.visibility = msg ? "visible" : "hidden";
        applyLockFromMessage(msg);
      });
    })();
  </script>

  <!-- Common Title -->
  <script>
    (function () {
      function applyCommonConfig(cfg) {
        if (!cfg || typeof cfg !== "object") return;

        // ê³µí†µ prefix (ì›í•˜ë©´ ì‚¬ìš©)
        var appName = cfg.appName || "4DReplay";
        var version = cfg.version || "V5";
        var pageCfg = (cfg.pages && cfg.pages.omsDashboard) || {};

        // 1) HTML <title>
        if (pageCfg.htmlTitle) {
          document.title = pageCfg.htmlTitle;
        } else {
          document.title = appName + " " + version + " - Dashboard";
        }

        // 2) í™”ë©´ ë‚´ H1 íƒ€ì´í‹€ + favicon ì´ë¯¸ì§€ prepend
        var h1 = document.getElementById("pageTitle");
        if (h1 && pageCfg.pageTitle) {

          // ê¸°ì¡´ í…ìŠ¤íŠ¸ ìœ ì§€
          h1.textContent = pageCfg.pageTitle;

          // ì•„ì´ì½˜ì´ ì´ë¯¸ ë¶™ì–´ ìˆìœ¼ë©´ ì¤‘ë³µ ì‚½ì… ê¸ˆì§€
          if (!h1.querySelector(".title-icon") && cfg.faviconHref) {
            var img = document.createElement("img");
            img.src = cfg.faviconHref;
            img.className = "title-icon";

            // í…ìŠ¤íŠ¸ í¬ê¸°ì— ìë™ ë§ì¶¤
            img.style.height = "1em";       // í…ìŠ¤íŠ¸ ë†’ì´ì™€ ë™ì¼
            img.style.width = "auto";       // ë¹„ìœ¨ ìœ ì§€
            img.style.verticalAlign = "-0.15em"; // í…ìŠ¤íŠ¸ baselineì— ë§ì¶”ê¸°
            img.style.marginRight = "8px";

            h1.prepend(img);
          }
        }

        // 3) favicon link êµì²´ (ë¸Œë¼ìš°ì € íƒ­ ì•„ì´ì½˜)
        if (cfg.faviconHref) {
          var existing = document.querySelector('link[rel="icon"]');
          if (!existing) {
            existing = document.createElement("link");
            existing.rel = "icon";
            existing.type = "image/x-icon";
            document.head.appendChild(existing);
          }
          existing.href = cfg.faviconHref;

          // ë§Œì•½ Titleì— ì´ë¯¸ ì•„ì´ì½˜ì´ ìˆì—ˆìœ¼ë©´ srcë„ ì—…ë°ì´íŠ¸
          var titleIcon = document.querySelector("#pageTitle .title-icon");
          if (titleIcon) {
            titleIcon.src = cfg.faviconHref;
          }
        }
      }
      function init() {
        // ì´ë¯¸ ë¡œë”©ë¼ ìˆìœ¼ë©´ ì¦‰ì‹œ í•œ ë²ˆ ì ìš©
        if (window.OmsCommonConfig) {
          applyCommonConfig(window.OmsCommonConfig);
        }
        // 4d-common-style.jsì—ì„œ oms:config-ready ì´ë²¤íŠ¸ ì˜ë‹ˆê¹Œ ê·¸ê²ƒë„ êµ¬ë…
        try {
          window.addEventListener("oms:config-ready", function (e) {
            applyCommonConfig(e.detail || window.OmsCommonConfig || {});
          });
        } catch (e) { /* ì´ë²¤íŠ¸ ë¯¸ì§€ì› ë¸Œë¼ìš°ì €ë©´ ë¬´ì‹œ */ }
      }
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
