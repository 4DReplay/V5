<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>4DReplay V5 - OMs System</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <link rel="icon" type="image/x-icon" href="web/images/4DMain.ico">

  <!-- proxy-safe asset loader: works for /proxy/<node>/... and direct port -->
  <script>
    (function () {
      // /proxy/<node>/... ÌôòÍ≤ΩÏóêÏÑúÎèÑ ÎèôÏûë
      const m = location.pathname.match(/^\/proxy\/([^/]+)/);
      const PROXY = m ? "/proxy/" + encodeURIComponent(m[1]) : "";
      const bust = "?v=" + Date.now();

      const ACTIONS_CANDIDATES = [
        PROXY + "/web/oms-actions.js",
        "./web/oms-actions.js",
        "./oms-actions.js",
        "/web/oms-actions.js"
      ];

      function injectJS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("script");
        el.defer = true;
        el.src = list[i] + bust;
        el.onerror = () => {
          console.warn("[OMS actions miss]", list[i]);
          injectJS(list, i + 1);
        };
        document.head.appendChild(el);
      }
      injectJS(ACTIONS_CANDIDATES);
    })();
  </script>
  
  <!-- e.g., /proxy/DMS-1/oms-system.html  =>  /proxy/DMS-1 -->
  <script>
    (function () {
      // e.g., /proxy/DMS-1/oms-system.html  =>  /proxy/DMS-1
      const m = location.pathname.match(/^\/proxy\/([^/]+)/);
      const PROXY_PREFIX = m ? "/proxy/" + encodeURIComponent(m[1]) : "";
      const bust = "?v=" + Date.now(); // cache-buster to avoid stale css/js

      const CSS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.css",
        "./4d-common-style.css",
      ];
      const JS_CANDIDATES = [
        PROXY_PREFIX + "/web/4d-common-style.js",
        "./4d-common-style.js",
      ];

      function injectCSS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("link");
        el.rel = "stylesheet"; el.href = list[i] + bust;
        el.onerror = () => { console.warn("[CSS miss]", list[i]); injectCSS(list, i + 1); };
        document.head.appendChild(el);
      }
      function injectJS(list, i = 0) {
        if (i >= list.length) return;
        const el = document.createElement("script");
        el.defer = true; el.src = list[i] + bust;
        el.onerror = () => { console.warn("[JS miss]", list[i]); injectJS(list, i + 1); };
        document.head.appendChild(el);
      }
      injectCSS(CSS_CANDIDATES);
      injectJS(JS_CANDIDATES);
    })();
  </script>
</head>


<!----------------------------------------------------------------------------------
BODY
------------------------------------------------------------------------------------>
<body>
  <h2 class="page-title">
    <span id="pageTitle">4DReplay V5 - OMs System</span>
    <small id="meta"></small>
  </h2>

  <div class="toolbar">
    <button id="btnDashboard" class="btn-secondary">üìä Dashboard</button>
    <button id="btnSysConfig" class="btn-secondary">üìù Config Editor</button>
    <button id="btnSysRestart" class="btn-secondary">‚ü≥ Restart All</button>
    <button id="btnSysConnect">üîå Connect</button>
    <button id="btnSysReload" class="btn-secondary">üîÑ Reload</button>    
    <span id="progressChip" class="chip" role="status" aria-live="polite"></span>
    <span class="spacer"></span>
    <span class="chip" id="hb">poll -</span>
  </div>
  <div id="err">    
  </div>
  <table id="grid">
    <thead>
      <tr>
        <th>Node</th>
        <th>Process</th>
        <th>Version</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <p class="muted" style="margin-top:10px">
    Tip: Clicking the title of each node allows you to manage the system.
  </p>  
  <script>
    const DEBUG = false;
    const TBody = document.querySelector("#grid tbody");
    const HB = document.getElementById("hb");
    const META = document.getElementById("meta");
    const PROG = document.getElementById("progressChip");
    const ERR = document.getElementById("err");
    const BTN_DASHBOARD   = document.getElementById("btnDashboard");
    const BTN_CONFIG      = document.getElementById("btnSysConfig");
    const BTN_SYS_RESTART = document.getElementById("btnSysRestart");
    const BTN_SYS_CONNECT = document.getElementById("btnSysConnect");
    const BTN_SYS_RELOAD  = document.getElementById("btnSysReload");    
    const PROG_LS_KEY = "oms_ra_progress"; // dashboardÏôÄ ÎèôÏùº ÌÇ§

    /* ‚îÄ‚îÄ ÏßÑÌñâ Î©îÏãúÏßÄ/Ï∫êÏãúÎ•º ÏôÑÏ†ÑÌûà ÎπÑÏö∞Îäî helper ‚îÄ‚îÄ */
    function clearProgressChip() {
      try {
        localStorage.removeItem(PROG_LS_KEY);
      } catch (e) {
        console.warn("clearProgressChip localStorage error", e);
      }
      if (PROG) {
        PROG.textContent = "";
        PROG.style.visibility = "hidden";
      }
    }

    let lastData = null;
    let OMS_ALIAS_MAP = {};
    let POLLER = null;
    let POLL_MS = 3000;

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Proxy-safe API prefix (works with /proxy/<node>/‚Ä¶) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const __PROXY_PREFIX__ = (() => {
      const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
      return m ? "/proxy/" + encodeURIComponent(decodeURIComponent(m[1])) : "";
    })();
    function api(path, init = {}) {
      const PFX = (typeof window !== "undefined" && window.__OMS_API_PREFIX__) || __PROXY_PREFIX__ || "";
      const url = (typeof path === "string" && path.startsWith("/")) ? (PFX + path) : path;
      return fetch(url, { cache: "no-store", ...init }).then(async (res) => {
        const ct = res.headers.get("content-type") || "";
        const isJson = ct.includes("application/json");
        const body = isJson ? await res.json().catch(() => ({})) : await res.text().catch(() => "");
        if (!res.ok) throw new Error(isJson ? (body.error || ("HTTP " + res.status)) : (body || ("HTTP " + res.status)));
        return body;
      });
    }

    function showErr(m) { ERR.style.display = "block"; ERR.textContent = m; }
    function clearErr() { ERR.style.display = "none"; ERR.textContent = ""; }

    function setBusy(on) {
      console.log("setBusy")
      BTN_SYS_RELOAD.disabled = !!on;
      BTN_CONFIG.disabled = !!on;
      BTN_SYS_RESTART.disabled = !!on;
      BTN_SYS_CONNECT.disabled = !!on;
    }

    function startPolling(ms) {
      if (typeof ms === "number" && isFinite(ms) && ms > 0) {
        POLL_MS = ms;
      }
      if (POLLER) clearInterval(POLLER);
      POLLER = setInterval(() => {
        reloadNow({ silent: true }).catch(() => {});
      }, POLL_MS);
      if (DEBUG) console.debug("[OMS] poll started:", POLL_MS, "ms");
    }
    function stopPolling() {
      if (POLLER) {
        clearInterval(POLLER);
        POLLER = null;
      }
    }
    function toProcList(status) {
      if (!status) return [];
      if (status.data && typeof status.data === "object") return Object.values(status.data);
      if (Array.isArray(status.processes)) return status.processes;
      if (Array.isArray(status.executables)) return status.executables;
      return [];
    }
    // ÏÑ†ÌÉù ÎåÄÏÉÅ ÌîÑÎ°úÏÑ∏Ïä§ Î¶¨Ïä§Ìä∏ (dms-system Í∑úÏπôÍ≥º ÎèôÏùºÌïòÍ≤å executables.select=true Í∏∞Ï§Ä)
    function selectedProcList(status) {
      if (!status) return [];
      const execs = Array.isArray(status.executables) ? status.executables : [];
      const procs = Array.isArray(status.processes) ? status.processes : [];
      const dataObjs = (status.data && typeof status.data === "object") ? Object.values(status.data) : [];

      const stateMap = Object.create(null);
      const ingest = (arr) => {
        for (const x of (arr || [])) {
          if (!x) continue;
          const nm = x.name || x.proc || x.id;
          if (!nm) continue;
          stateMap[nm] = { ...(stateMap[nm] || {}), ...x, name: nm };
        }
      };
      ingest(procs);
      ingest(execs);
      ingest(dataObjs);

      const normRunning = (v) => {
        if (typeof v === "boolean") return v;
        const s = String(v || "").trim().toLowerCase();
        return s === "running" || s === "started";
      };

      const base = execs.length ? execs : (procs.length ? procs : dataObjs);
      return base
        .filter(e => e && (e.select !== false))
        .map(e => {
          const nm = e.name || e.proc || e.id;
          const ref = stateMap[nm] || {};
          const running = normRunning(ref.running ?? ref.status ?? e.running ?? e.status);
          return {
            name: nm,
            alias: e.alias || ref.alias || "",
            select: e.select !== false,
            running,
            connection_state: ref.connection_state || e.connection_state || null,
            version: ref.version || e.version,
            version_date: ref.version_date || e.version_date,
          };
        });
    }
    function nodeCellHtml(n, procIndex, procTotal) {
      const href = "/proxy/" + encodeURIComponent(n.name) + "/dms-system.html";
      const suffix = (typeof procIndex === "number" && typeof procTotal === "number" && procTotal > 0)
        ? " (" + (procIndex + 1) + "/" + procTotal + ")" : "";
      return '<a class="node" href="' + href + '" target="_blank">' + (n.alias || n.name) + '</a><br>' +
             '<span class="muted">' + n.host + ":" + n.port + suffix + "</span>";
    }
    function applyOverlays(data) {
      const extra = (data && data.extra) || {};
      const verMap = extra.versions || {};
      const presdVer = extra.presd_versions || {};
      const conn = extra.connected_daemons || {};
      const presdIps = extra.presd_ips || [];
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];

      const ipFromHost = (s) => {
        const m = String(s || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s || "");
      };
      const listFromStatus = (status) => {
        if (!status) return [];
        if (status.data && typeof status.data === "object") return Object.values(status.data);
        if (Array.isArray(status.processes)) return status.processes;
        if (Array.isArray(status.executables)) return status.executables;
        return [];
      };

      for (const n of nodes) {
        const nodeIp = ipFromHost(n.host);
        const procs = listFromStatus(n.status);
        for (const p of procs) {
          if (!p || !p.name) continue;

          // Î≤ÑÏ†Ñ Ïò§Î≤ÑÎ†àÏù¥
          if (p.name === "PreSd") {
            const src =
              presdVer[nodeIp] ||
              (verMap.PreSd && (verMap.PreSd[nodeIp] || (verMap.PreSd.byIp && verMap.PreSd.byIp[nodeIp]))) ||
              null;
            if (src) {
              p.version = src.version || "-";
              p.version_date = src.date || "-";
            } else if (verMap.PreSd && verMap.PreSd.version) {
              p.version = verMap.PreSd.version || "-";
              p.version_date = verMap.PreSd.date || "-";
            }
          } else if (verMap[p.name]) {
            p.version = verMap[p.name].version || p.version || "-";
            p.version_date = verMap[p.name].date || p.version_date || "-";
          }

          // CONNECTED Ïò§Î≤ÑÎ†àÏù¥ (PCd / PreSd)
          if (conn && conn[p.name] === true) {
            if (p.name === "PreSd") {
              const ipOk = !presdIps.length || presdIps.includes(nodeIp);
              if (ipOk) p.connection_state = "CONNECTED";
            } else {
              p.connection_state = "CONNECTED";
            }
          }
        }
      }

      // alias_map Ï†ÑÎã¨
      OMS_ALIAS_MAP = extra.alias_map || {};
    }
    function effectiveStateOf(procObj) {
      if (!procObj) return "STOPPED";
      const running = !!procObj.running;
      const conn = String(procObj.connection_state || "").toUpperCase();
      if (!running) return "STOPPED";
      if (conn === "CONNECTED") return "CONNECTED";
      return "RUNNING";
    }
    function render(data) {
      if (!data) return;
      applyOverlays(data);
      lastData = data;

      const hbSecRaw = Number(data && data.heartbeat_interval_sec);
      const nodes = Array.isArray(data.nodes) ? data.nodes : [];
      let procTotal = 0;
      let connectedTotal = 0;
      let runningTotal = 0;
      let stoppedTotal = 0;

      if (!Number.isNaN(hbSecRaw) && hbSecRaw > 0) {
        const nextMs = Math.max(800, Math.min(10000, Math.floor(hbSecRaw * 1000)));
        if (nextMs !== POLL_MS) startPolling(nextMs);
        HB.textContent = "poll " + hbSecRaw + "s";
      } else {
        HB.textContent = "poll -";
      }

      TBody.innerHTML = "";
      if (nodes.length === 0) {
        const bullet = "\u2022";
        META.textContent = "nodes: 0 " + bullet + " processes: 0 " + bullet + " connected: 0";
        TBody.innerHTML = '<tr class="other"><td colspan="5" class="muted">no nodes</td></tr>';
        return;
      }

      const VERS = (data && data.extra && data.extra.versions) || {};
      const PRESD_VERS = (data && data.extra && data.extra.presd_versions) || {};
      const ipOf = (s) => {
        const m = String(s || "").match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
        return m ? m[0] : String(s || "");
      };

      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        let shown = selectedProcList(n.status);
        procTotal += shown.length;

        if (!n.status) {
          TBody.insertAdjacentHTML("beforeend",
            '<tr class="other"><td>' + nodeCellHtml(n, 0, 0) + '</td><td colspan="4" class="muted">unreachable</td></tr>');
          continue;
        }

        if (shown.length === 0) {
          const fallback = toProcList(n.status).map(x => ({
            name: (x && (x.name || x.proc || x.id)) || "-",
            alias: (x && x.alias) || "",
            running: !!(x && (x.running || String(x.status || "").toLowerCase() === "running")),
            connection_state: (x && x.connection_state) || null,
            select: true
          }));
          if (fallback.length > 0) {
            shown = fallback;
          } else {
            TBody.insertAdjacentHTML("beforeend",
              '<tr class="other"><td>' + nodeCellHtml(n, 0, 0) + '</td><td colspan="4" class="muted">no processes</td></tr>');
            continue;
          }
        }

        for (let j = 0; j < shown.length; j++) {
          const p = shown[j];
          const nodeIp = ipOf(n.host);

          const _rv = (proc, ip) => {
            if (p && typeof p.version === "string" && p.version.trim()) return p.version;
            if (proc === "PreSd") {
              return (PRESD_VERS[ip]?.version)
                || (VERS.PreSd?.[ip]?.version)
                || (VERS.PreSd?.byIp?.[ip]?.version)
                || (VERS.PreSd?.version)
                || "-";
            }
            return (VERS[proc]?.version) || "-";
          };

          const eff = effectiveStateOf(p);
          if (eff === "CONNECTED") connectedTotal += 1;
          else if (eff === "RUNNING") runningTotal += 1;
          else stoppedTotal += 1;

          const badge =
            eff === "STOPPED" ? '<span class="pill bad">STOPPED</span>' :
            eff === "CONNECTED" ? '<span class="pill connected">CONNECTED</span>' :
            '<span class="pill ok">RUNNING</span>';

          const rowCls = (eff === "STOPPED") ? "stopped" : "running";
          const verText = _rv(p.name, nodeIp);
          const dateText = (p && typeof p.version_date === "string" && p.version_date.trim())
            ? p.version_date
            : (p.name === "PreSd"
              ? (PRESD_VERS[nodeIp]?.date
                || VERS.PreSd?.[nodeIp]?.date
                || VERS.PreSd?.byIp?.[nodeIp]?.date
                || VERS.PreSd?.date
                || "-")
              : (VERS[p.name]?.date || "-"));
          const verHtml = verText + '<br><span class="muted">' + (dateText || "-") + "</span>";

          const dmsAlias = (p.alias || "").trim();
          const omsAlias = (OMS_ALIAS_MAP[p.name] || "").trim();
          let aliasHtml = "";
          if (dmsAlias && omsAlias && dmsAlias !== omsAlias) {
            aliasHtml = '<br><span class="muted" title="OMS alias: ' + omsAlias + '">' + dmsAlias + "</span>";
          } else {
            const a = dmsAlias || omsAlias;
            aliasHtml = a ? '<br><span class="muted">' + a + "</span>" : "";
          }

          TBody.insertAdjacentHTML("beforeend",
            '<tr class="' + rowCls + '">' +
              '<td>' + nodeCellHtml(n, j, shown.length) + "</td>" +
              '<td>' + (p.name || "-") + aliasHtml + "</td>" +
              '<td>' + verHtml + "</td>" +
              '<td>' + badge + "</td>" +
              '<td><button class="btn-secondary" data-a="logs" data-node="' +
                n.name + '" data-proc="' + p.name + '">üìú Logs</button></td>' +
            "</tr>");
        }
      }

      const bullet = "\u2022";
      const nodesCount = nodes.length;
      const processesCount = procTotal;
      const connectedCount = connectedTotal;
      const runningCount = runningTotal;
      const stoppedCount = stoppedTotal;

      META.textContent =
        `nodes: ${nodesCount} ‚Ä¢ processes: ${processesCount} ( connected: ${connectedCount} / running: ${runningCount} / stopped: ${stoppedCount} )`;

      const OSM_SUMMARY = {
        nodes: nodesCount,
        processes: processesCount,
        connected: connectedCount,
        running: runningCount,
        stopped: stoppedCount,
        ts: Date.now(),
        source: "oms-system"
      };
      try {
        window.OMS = window.OMS || {};
        window.OMS.summary = OSM_SUMMARY;
        window.dispatchEvent(new CustomEvent("oms:summary", { detail: OSM_SUMMARY }));
      } catch (e) {
        if (DEBUG) console.warn("oms:summary dispatch failed", e);
      }
    }
    async function reloadNow(opts = {}) {
      const silent = !!opts.silent;
      try {
        if (!silent) setBusy(true);
        clearErr();
        const data = await api("/oms/status");
        render(data);
      } catch (e) {
        showErr(e.message || String(e));
      } finally {
        if (!silent) setBusy(false);
      }
    }
    document.querySelector("#grid tbody").addEventListener("click", ev => {
      const b = ev.target.closest("button"); if (!b) return;
      if (b.dataset.a === "logs") {
        const url = "/web/log-viewer.html?node=" +
          encodeURIComponent(b.dataset.node) +
          "&name=" + encodeURIComponent(b.dataset.proc);
        window.open(url, "_blank");
      }
    });

    // ========================================================================
    // Button Action
    // ========================================================================
    
    // ‚îÄ [Button] Reload ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_SYS_RELOAD.onclick = () => reloadNow({ silent: false });
    // ‚îÄ [Button] Restart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_SYS_RESTART.onclick = () => {
        // ‚úÖ Restart ÏãúÏûë Ï†ÑÏóê ÏßÄÎÇú ÏßÑÌñâ Î©îÏãúÏßÄ ÏôÑÏ†ÑÌûà ÏÇ≠Ï†ú
        console.log("BTN_SYS_RESTART.onclick")
        clearProgressChip();

        window.OMS = window.OMS || {};
        window.OMS.Actions = window.OMS.Actions || {};
        const Actions = window.OMS.Actions;
    
        // JS helperÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏ Î®ºÏ†Ä ÏÇ¨Ïö©
        if (Actions && typeof Actions.sysRestart === "function") {
            Actions.sysRestart().catch(e => {
                const msg = String(e?.message || e || "");
                alert("Restart-All failed: " + msg);
            });
            return;
        }
      
        // fallback: ÏßÅÏ†ë API Ìò∏Ï∂ú
        api("/oms/sys-restart/all", { method: "POST" })
            .catch(e => {
                const msg = String(e?.message || e || "");
                alert("Restart-All failed: " + msg);
            });
    };
    // ‚îÄ [Button] Connect ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_SYS_CONNECT.onclick = () => {
      // ‚úÖ Connect ÏãúÏûë ÏãúÏóêÎèÑ ÏßÄÎÇú Î©îÏãúÏßÄ clear
      clearProgressChip();
      // ÏßÑÌñâÏπ©ÏùÄ actions.jsÏóêÏÑú chipMsgÎ°ú Í¥ÄÎ¶¨ÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Îã®Ïàú Ìä∏Î¶¨Í±∞Îßå
      try {
        if (window.OMS && window.OMS.Actions && typeof window.OMS.Actions.sysConnect === "function") {
          window.OMS.Actions.sysConnect();
        } else {
          // ÌïÑÏöî ÏóÜÏúºÎ©¥ fallback ÏôÑÏ†ÑÌûà Ï†úÍ±∞ÌïòÍ±∞ÎÇò,
          // "ÏßÄÏõêÎêòÏßÄ ÏïäÎäî ÌôòÍ≤Ω" Ï†ïÎèÑÎßå Î°úÍ∑∏Î°ú ÎÇ®Í∏∞Í∏∞
          console.error("sysConnect not available");
        }
      } catch (e) {
        console.error(e);
      }
    };
    // ‚îÄ [Button] Dashboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_DASHBOARD.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      window.location.href = base + "/dashboard";
    };
    // ‚îÄ [Button] Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    BTN_CONFIG.onclick = () => {
      const base = __PROXY_PREFIX__ || "";
      window.location.href = base + "/web/oms-config.html";
    };

    // ÌéòÏù¥ÏßÄÍ∞Ä Ï§ÄÎπÑÎêòÎ©¥ actions Î†àÏù¥Ïñ¥Ïóê hookÍ≥º uiÎ•º ÎÑòÍ≤®Ï§ÄÎã§
    function mountActionsOnce() {
      if (!(window.OMS && window.OMS.Actions)) return;
      try {
        window.OMS.Actions.mountPage({
          hooks: {
            reloadNow: (opts) => reloadNow(opts),
            render: (data) => render(data)
          }
        });
        if (window.OMS.__ui && typeof window.OMS.Actions.setUi === "function") {
          window.OMS.Actions.setUi(window.OMS.__ui);
        }
      } catch (e) {
        console.error("mountPage failed", e);
      }
    }
    // Ï¥àÍ∏∞ Î∂ÄÌåÖ: Ìïú Î≤àÎßå Î™ÖÏãúÏ†ÅÏúºÎ°ú Ìò∏Ï∂ú
    (function bootstrap() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          reloadNow({ silent: false }).catch(e => console.error(e));
          startPolling(POLL_MS);
        });
      } else {
        reloadNow({ silent: false }).catch(e => console.error(e));
        startPolling(POLL_MS);
      }

      // Summary Ïù¥Î≤§Ìä∏Î°ú Title ÏòÜ metaÎèÑ Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
      window.addEventListener("oms:summary", (ev) => {
          const d = ev.detail || {};
          const bullet = "\u2022";
          META.textContent =
            "nodes: " + (d.nodes || 0) + " " + bullet +
            " processes: " + (d.processes || 0) +
            " ( connected: " + (d.connected || 0) +
            " / running: " + (d.running || 0) +
            " / stopped: " + (d.stopped || 0) + " )";
      });

    })();

    // ‚îÄ Restart Lock 
    (function syncRestartLock() {
      console.log("syncRestartLock")
      function applyLock(locked) {
        const on = !!locked;
        if (BTN_SYS_RESTART) BTN_SYS_RESTART.disabled = on;
        if (BTN_SYS_CONNECT) BTN_SYS_CONNECT.disabled = on;
      }

      // ÌéòÏù¥ÏßÄ ÏßÑÏûÖ Ïãú ÌòÑÏû¨ lock ÏÉÅÌÉú Ìïú Î≤à Î∞òÏòÅ
      try {
        if (window.OMS && window.OMS.Actions && typeof window.OMS.Actions.isSysRestartLocked === "function") {
          applyLock(window.OMS.Actions.isSysRestartLocked());
        }
      } catch { }

      // BroadcastChannel Î°ú Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî
      try {
        const bc = new BroadcastChannel("oms-restart-lock");
        bc.onmessage = (e) => {
          if (!e || !e.data) return;
          applyLock(!!e.data.locked);
        };
      } catch { }
    })();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Unified Progress Poller & Chip Sync ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function getTitleChipEl() {
      // oms-systemÏùò chipÏùÄ progressChip Ïù¥Îã§
      return document.getElementById("progressChip");
    }

    (function unifiedProgressManager() {
      const KEY = PROG_LS_KEY;
      const INTERVAL = 1000;

      function applyLockFromMessage(msgRaw) {

        console.log("applyLockFromMessage", msgRaw)

        const msg = String(msgRaw || "").trim().toLowerCase();
        if (!msg.startsWith("[system][restart]")) 
          return;

        BTN_SYS_RESTART.disabled = true;
        BTN_SYS_CONNECT.disabled = true;
        
        if (
          msg.includes("finished") ||
          /\b(finished|done|complete)\b/.test(msg) ||
          msg.includes("restart-all done") ||
          msg.includes("restart-all failed")
        ) {
          BTN_SYS_RESTART.disabled = false;
          BTN_SYS_CONNECT.disabled = false;
        }
      }

      // ÏµúÏ¥à Ï∫êÏãú UI Î∞òÏòÅ
      try {
        const cached = localStorage.getItem(KEY);
        if (cached && PROG) {
          const msg = cached.trim();

          // debug
          console.log("unifiedProgressManager",msg)
          PROG.textContent = msg;
          PROG.style.visibility = msg ? "visible" : "hidden";
          applyLockFromMessage(msg);
        }
      } catch {}

      // Îã§Î•∏ ÌÉ≠ sync
      window.addEventListener("storage", (e) => {
        if (e.key !== KEY || typeof e.newValue !== "string") return;
        const msg = e.newValue.trim();
        PROG.textContent = msg;
        PROG.style.visibility = msg ? "visible" : "hidden";
        applyLockFromMessage(msg);
      });
    })();
  </script>

  <!-- Common Title -->
  <script>
    (function () {
      function applyCommonConfig(cfg) {
        if (!cfg || typeof cfg !== "object") return;
        var appName = cfg.appName || "4DReplay";
        var version = cfg.version || "V5";
        var pageCfg = (cfg.pages && cfg.pages.omsSystem) || {};

        // 1) HTML <title>
        if (pageCfg.htmlTitle) {
          document.title = pageCfg.htmlTitle;
        } else {
          document.title = appName + " " + version + " - OMs System";
        }
        // 2) ÌôîÎ©¥ ÏÉÅÎã® H2 ÏïàÏùò ÌÉÄÏù¥ÌãÄ ÌÖçÏä§Ìä∏
        var h = document.getElementById("pageTitle");
        if (h && pageCfg.pageTitle) {
          h.textContent = pageCfg.pageTitle;
        }
        // 3) favicon (Í≥µÌÜµ)
        if (cfg.faviconHref) {
          var link = document.querySelector('link[rel="icon"]');
          if (!link) {
            link = document.createElement("link");
            link.rel = "icon";
            link.type = "image/x-icon";
            document.head.appendChild(link);
          }
          link.href = cfg.faviconHref;
        }
      }
      function init() {
        // Ïù¥ÎØ∏ Î°úÎî©Îèº ÏûàÏúºÎ©¥ Ï¶âÏãú Ìïú Î≤à Ï†ÅÏö©
        if (window.OmsCommonConfig) {
          applyCommonConfig(window.OmsCommonConfig);
        }
        // 4d-common-style.jsÏóêÏÑú oms:config-ready Ïù¥Î≤§Ìä∏ ÏèòÎãàÍπå Í∑∏Í≤ÉÎèÑ Íµ¨ÎèÖ
        try {
          window.addEventListener("oms:config-ready", function (e) {
            applyCommonConfig(e.detail || window.OmsCommonConfig || {});
          });
        } catch (e) { /* Ïù¥Î≤§Ìä∏ ÎØ∏ÏßÄÏõê Î∏åÎùºÏö∞Ï†ÄÎ©¥ Î¨¥Ïãú */ }
      }
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
