<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>4DReplay V5 - DMs Dashboard</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <style>
    :root{
      --bg:#0b0f14; --fg:#eef2f7; --muted:#94a3b8;
      --card:#0b1220; --line:#1f2937; --line2:#243045;
      --ok:#16a34a; --bad:#ef4444; --off:#52525b;
      --btn:#1e40af; --btn2:#334155;
    }
    body{background:var(--bg);color:var(--fg);font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px}
    h2{font-size:32px;margin:0 0 14px;display:flex;align-items:center;gap:8px}
    h2 small{font-size:14px;opacity:.8}
    .toolbar{display:flex;gap:10px;margin:8px 0 16px;align-items:center;flex-wrap:wrap}
    .toolbar small{opacity:.8;margin-left:8px}
    button{background:var(--btn);color:#fff;border:0;border-radius:10px;padding:10px 14px;cursor:pointer;display:inline-flex;align-items:center;gap:6px;transition:filter .2s ease;}
    button.btn-secondary{background:var(--btn2)}
    button:hover{filter:brightness(1.15)}
    button[disabled]{opacity:.6;cursor:not-allowed}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid var(--line2);padding:10px}
    th{background:#0f172a;text-align:left}
    tr.running{background:#06220a}
    tr.stopped{background:#1b0f0f}
    tr.disabled{background:#111827}
    .pill{display:inline-block;padding:3px 10px;border-radius:14px;font-size:12px;border:1px solid}
    .ok{background:#0d3b1a;border-color:#16a34a;color:#a7f3d0}
    .bad{background:#3b0d0d;border-color:#ef4444;color:#fecaca}
    .off{background:#27272a;border-color:#52525b;color:#d4d4d8}
    .select-cell{display:flex;gap:6px;align-items:center}
    .namecell small{opacity:.8}
    #err{display:none;margin:8px 0;padding:10px;border-radius:8px;background:#3b0d0d;border:1px solid #ef4444;color:#ffe0e0;white-space:pre-wrap}
  </style>
</head>
<body>
  <h2>
    <span>4DReplay V5 - DMs Dashboard</span>
    <small id="titleHost"></small>
  </h2>

  <div class="toolbar">
    <button id="btnConfig" class="btn-secondary">📝 Config Editor</button>
    <button id="btnStartAll">▶ Start All</button>
    <button id="btnStopAll"  class="btn-secondary">■ Stop All</button>
    <button id="btnRestartAll" class="btn-secondary">⟳ Restart All</button>
    <!-- ✅ Reload 버튼 추가 -->
    <button id="btnReload" class="btn-secondary">🔄 Reload</button>
    <small id="busyMsg"></small>
  </div>

  <div id="err"></div>

  <table id="grid">
    <thead>
      <tr>
        <th style="width:110px">Select</th>
        <th style="width:280px">Name / Alias</th>
        <th>Exe</th>
        <th style="width:120px">PID</th>
        <th style="width:160px">Status</th>
        <th style="width:120px">Last RC</th>
        <th style="width:460px">Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <p class="small" id="beat">Auto refresh: -</p>

<script>
/* ───────────────── Proxy 지원 ───────────────── */
const __PROXY_PREFIX__ = (() => {
  const m = location.pathname.match(/^\/proxy\/([^/]+)\//);
  return m ? `/proxy/${encodeURIComponent(decodeURIComponent(m[1]))}` : "";
})();
(function ensureBase(){
  if (!__PROXY_PREFIX__) return;
  const base = document.createElement("base");
  base.href = __PROXY_PREFIX__ + "/";
  document.head.prepend(base);
})();
(function patchFetch(){
  if (!__PROXY_PREFIX__) return;
  const orig = window.fetch;
  window.fetch = function(input, init){
    let url = input;
    if (typeof input !== "string" && input && input.url) url = input.url;
    if (typeof url === "string") {
      if (url.startsWith("/") && !url.startsWith("/proxy/")) {
        url = __PROXY_PREFIX__ + url;
      }
    }
    if (typeof input !== "string" && input && input.url) {
      return orig(new Request(url, input), init);
    }
    return orig(url, init);
  };
})();

/* ───────────────── 공통 API ───────────────── */
async function api(path, opts={}){
  const r = await fetch(path, Object.assign({cache:"no-store"}, opts));
  if(!r.ok){ const t=await r.text().catch(()=>String(r.status)); throw new Error(t||`HTTP ${r.status}`); }
  const ct = r.headers.get("content-type")||"";
  return ct.includes("application/json") ? r.json() : r.text();
}

/* ───────────────── DOM ───────────────── */
const TBody = document.querySelector("#grid tbody");
const ERR   = document.getElementById("err");
const TITLE = document.getElementById("titleHost");
const BEAT  = document.getElementById("beat");
const BUSY  = document.getElementById("busyMsg");
if (TITLE) TITLE.textContent = `(${location.hostname || "-"})`;

document.getElementById("btnConfig").onclick    = ()=>location.href="dms-config.html";
document.getElementById("btnStartAll").onclick   = ()=>{ if(!IS_BUSY) bulk("start");   };
document.getElementById("btnStopAll").onclick    = ()=>{ if(!IS_BUSY) bulk("stop");    };
document.getElementById("btnRestartAll").onclick = ()=>{ if(!IS_BUSY) bulk("restart"); };
// ✅ Reload 클릭 핸들러
document.getElementById("btnReload").onclick = async ()=>{
  if (IS_BUSY) return;
  try { setBusy(true, "RELOAD..."); clearErr(); await tick(); }
  catch(e){ showErr("Reload failed: " + (e.message||e)); }
  finally { setBusy(false); }
};

/* ───────────────── 상태 ───────────────── */
let CFG = null;    // /config-format 결과(JSON)
let STATUS = null; // /status 결과(JSON)

function showErr(m){ ERR.style.display="block"; ERR.textContent=m; }
function clearErr(){ ERR.style.display="none"; ERR.textContent=""; }

let IS_BUSY = false;
function setBusy(flag,msg=""){
  IS_BUSY = !!flag;
  // ✅ Reload 버튼도 비활성화 대상에 포함
  for (const id of ["btnStartAll","btnStopAll","btnRestartAll","btnConfig","btnReload"]) {
    const b = document.getElementById(id);
    if (b) b.disabled = IS_BUSY;
  }
  BUSY.textContent = msg || "";
}

/* helpers */
function toList(status){
  if (!status) return [];
  if (status.data && typeof status.data === "object") return Object.values(status.data);
  if (Array.isArray(status.processes)) return status.processes;
  if (Array.isArray(status.executables)) return status.executables;
  return [];
}
function row(item){
  const tr = document.createElement("tr");
  const selected = item.select === true;
  const running  = !!item.running;
  tr.className = selected ? (running ? "running" : "stopped") : "disabled";
  const exeShort = (item.exe||"").split(/[\\/]/).slice(-2).join("/");
  const badge = !selected
      ? `<span class="pill off">DISABLED</span>`
      : (running ? `<span class="pill ok">RUNNING</span>`
                 : `<span class="pill bad">STOPPED</span>`);
  tr.innerHTML = `
    <td>
      <div style="display:flex;align-items:center;gap:8px">
        <input type="checkbox" data-a="toggle" data-n="${item.name}" ${selected?"checked":""}>
        <span>${selected?"on":"off"}</span>
      </div>
    </td>
    <td>
      <div style="font-weight:700">${item.name||"-"}</div>
      ${item.alias ? `<div class="small">${item.alias}</div>` : `<div class="small">-</div>`}
    </td>
    <td class="small" title="${item.exe||""}">${exeShort||"-"}</td>
    <td>${item.pid ?? "-"}</td>
    <td>${badge}</td>
    <td>${item.last_rc ?? "-"}</td>
    <td>
      <button data-a="start"   data-n="${item.name}" ${selected?"":"disabled"}>Start</button>
      <button class="btn-secondary" data-a="stop" data-n="${item.name}">Stop</button>
      <button class="btn-secondary" data-a="restart" data-n="${item.name}" ${selected?"":"disabled"}>Restart</button>
      <button class="btn-secondary" data-a="logs" data-n="${item.name}">📜 Logs</button>
    </td>
  `;
  return tr;
}
function render(){
  clearErr();
  const cfgExecs = (CFG && Array.isArray(CFG.executables)) ? CFG.executables : [];
  const statusMap = {};
  for (const s of toList(STATUS)) statusMap[s.name] = s;
  TBody.innerHTML = "";
  for (const c of cfgExecs){
    const s = statusMap[c.name] || {};
    const item = {
      name: c.name,
      alias: c.alias || s.alias || "",
      exe: c.path || s.path || s.exe || "",
      select: c.select === true,
      running: !!s.running,
      pid: s.pid ?? "-",
      last_rc: (s.last_rc ?? s.last_exit_code) ?? "-"
    };
    TBody.appendChild(row(item));
  }
}

/* 행/체크·개별 버튼 */
TBody.addEventListener("click", async (ev)=>{
  const btn = ev.target.closest("button");
  const chk = ev.target.closest('input[type="checkbox"][data-a="toggle"]');
  if (chk){
    try{
      const name = chk.dataset.n;
      const ex = CFG.executables.find(e=>e.name===name);
      if (ex){ ex.select = chk.checked; }
      const formatted = await api("/config-format", {method:"POST", body: JSON.stringify(CFG)});
      await api("/config", {method:"POST", body: formatted.text});
      await tick();
    }catch(e){ showErr("Update select failed: "+(e.message||e)); }
    return;
  }
  if (!btn) return;
  const act = btn.dataset.a, name = btn.dataset.n;
  if (act === "logs"){
    window.open(`web/log-viewer.html?name=${encodeURIComponent(name)}&tail=50000`, "_blank");
    return;
  }
  try{
    await api(`/${act}/${encodeURIComponent(name)}`, {method:"POST"});
    await waitForRunning(name, act === "stop" ? false : true, ACTION_TIMEOUTS[act] || 120_000);
    await tick();
  }catch(e){ showErr(`${act.toUpperCase()} failed: `+(e.message||e)); }
});

/* ───────── 병렬 Bulk (Start/Stop/Restart) ───────── */
const ACTION_TIMEOUTS = { start: 180_000, stop: 150_000, restart: 240_000 };

function listFromStatus(st){
  return (st && st.data && typeof st.data === "object") ? Object.values(st.data)
       : (Array.isArray(st.processes)   ? st.processes
       :  Array.isArray(st.executables) ? st.executables : []);
}
async function readProc(name){
  try{
    const st = await api("/status");
    const arr = listFromStatus(st);
    return arr.find(x => x && x.name === name);
  }catch{ return null; }
}
async function waitForRunning(name, wantRunning, totalTimeoutMs, pollEveryMs=1200){
  const t0 = Date.now();
  while (Date.now() - t0 < totalTimeoutMs){
    const p = await readProc(name);
    if (p && !!p.running === !!wantRunning) return { ok:true };
    await new Promise(r=>setTimeout(r,pollEveryMs));
  }
  return { ok:false, msg:"timeout" };
}

async function bulk(action){
  if (!CFG || !Array.isArray(CFG.executables)) return;
  const targets = CFG.executables.filter(e=>e.select===true).map(e=>e.name);
  if (!targets.length){ showErr("No selected processes."); return; }

  const label  = action.toUpperCase();
  const want   = (action !== "stop");
  const budget = ACTION_TIMEOUTS[action] || 180_000;

  setBusy(true, `${label}... (0/${targets.length})`);

  let done = 0;
  const results = await Promise.all(
    targets.map((name) =>
      (async () => {
        try { await api(`/${action}/${encodeURIComponent(name)}`, { method:"POST" }); }
        catch(_) {}
        const waited = await waitForRunning(name, want, budget);
        if (!waited.ok) throw new Error(waited.msg || "timeout");
        return { ok:true };
      })()
      .then(
        () => { done++; setBusy(true, `${label}... (${done}/${targets.length})`); return { ok:true }; },
        (e)  => { done++; setBusy(true, `${label}... (${done}/${targets.length})`); return { ok:false, msg:`${name}: ${e.message||e}` }; }
      )
    )
  );

  const okCount   = results.filter(r => r.ok).length;
  const failItems = results.filter(r => !r.ok);

  setBusy(false, `${label} done: ${okCount} ok, ${failItems.length} failed`);

  if (failItems.length){
    showErr(`${label} failures:\n` + failItems.map(f => f.msg).join("\n"));
  } else {
    clearErr();
  }

  await tick();
}

/* ───────── 표시용 Host 추출 & 주기 폴링 ───────── */
function pickDisplayHost(st){
  const pick = (o)=> {
    if (!o || typeof o !== "object") return "";
    for (const k of ["host","hostname","ip","ipaddr","ip_addr","address","addr"]) {
      const v = o[k]; if (v && String(v).trim()) return String(v).trim();
    }
    return "";
  };
  let v = pick(st) || pick(st?.node) || pick(st?.server) || pick(st?.meta) || pick(st?.config);
  if (v) return v;
  const m = location.pathname.match(/^\/proxy\/([^/]+)/);
  if (m && m[1]) return m[1];
  return location.hostname || "";
}

async function tick(){
  try{
    STATUS = await api("/status");
    const hostHint = pickDisplayHost(STATUS);
    if (hostHint) TITLE.textContent = `(${hostHint})`;
    const hb = Number(STATUS.heartbeat_interval_sec||2);
    BEAT.textContent = `ON (${hb}s)`;
    if (!CFG){
      const raw = await api("/config","GET"); // 기존 로직 유지
      const fm  = await api("/config-format",{method:"POST", body: raw});
      CFG = JSON.parse(fm.text);
    }
    render();
  }catch(e){
    showErr("Tick failed: "+(e.message||e));
  }
}
tick();
setInterval(tick, 2000);
</script>
</body>
</html>
